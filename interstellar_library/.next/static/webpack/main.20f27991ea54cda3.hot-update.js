"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("main",{

/***/ "./node_modules/next/dist/client/index.js":
/*!************************************************!*\
  !*** ./node_modules/next/dist/client/index.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("/* global location */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$();\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    version: function() {\n        return version;\n    },\n    router: function() {\n        return router;\n    },\n    emitter: function() {\n        return emitter;\n    },\n    initialize: function() {\n        return initialize;\n    },\n    hydrate: function() {\n        return hydrate;\n    }\n});\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"./node_modules/@swc/helpers/esm/_interop_require_default.js\");\n__webpack_require__(/*! ../build/polyfills/polyfill-module */ \"./node_modules/next/dist/build/polyfills/polyfill-module.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nconst _client = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react-dom/client */ \"./node_modules/react-dom/client.js\"));\nconst _headmanagercontext = __webpack_require__(/*! ../shared/lib/head-manager-context */ \"./node_modules/next/dist/shared/lib/head-manager-context.js\");\nconst _mitt = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../shared/lib/mitt */ \"./node_modules/next/dist/shared/lib/mitt.js\"));\nconst _routercontext = __webpack_require__(/*! ../shared/lib/router-context */ \"./node_modules/next/dist/shared/lib/router-context.js\");\nconst _handlesmoothscroll = __webpack_require__(/*! ../shared/lib/router/utils/handle-smooth-scroll */ \"./node_modules/next/dist/shared/lib/router/utils/handle-smooth-scroll.js\");\nconst _isdynamic = __webpack_require__(/*! ../shared/lib/router/utils/is-dynamic */ \"./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\");\nconst _querystring = __webpack_require__(/*! ../shared/lib/router/utils/querystring */ \"./node_modules/next/dist/shared/lib/router/utils/querystring.js\");\nconst _runtimeconfig = __webpack_require__(/*! ../shared/lib/runtime-config */ \"./node_modules/next/dist/shared/lib/runtime-config.js\");\nconst _utils = __webpack_require__(/*! ../shared/lib/utils */ \"./node_modules/next/dist/shared/lib/utils.js\");\nconst _portal = __webpack_require__(/*! ./portal */ \"./node_modules/next/dist/client/portal/index.js\");\nconst _headmanager = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./head-manager */ \"./node_modules/next/dist/client/head-manager.js\"));\nconst _pageloader = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./page-loader */ \"./node_modules/next/dist/client/page-loader.js\"));\nconst _performancerelayer = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./performance-relayer */ \"./node_modules/next/dist/client/performance-relayer.js\"));\nconst _routeannouncer = __webpack_require__(/*! ./route-announcer */ \"./node_modules/next/dist/client/route-announcer.js\");\nconst _router = __webpack_require__(/*! ./router */ \"./node_modules/next/dist/client/router.js\");\nconst _iserror = __webpack_require__(/*! ../lib/is-error */ \"./node_modules/next/dist/lib/is-error.js\");\nconst _imageconfigcontext = __webpack_require__(/*! ../shared/lib/image-config-context */ \"./node_modules/next/dist/shared/lib/image-config-context.js\");\nconst _removebasepath = __webpack_require__(/*! ./remove-base-path */ \"./node_modules/next/dist/client/remove-base-path.js\");\nconst _hasbasepath = __webpack_require__(/*! ./has-base-path */ \"./node_modules/next/dist/client/has-base-path.js\");\nconst _approutercontext = __webpack_require__(/*! ../shared/lib/app-router-context */ \"./node_modules/next/dist/shared/lib/app-router-context.js\");\nconst _adapters = __webpack_require__(/*! ../shared/lib/router/adapters */ \"./node_modules/next/dist/shared/lib/router/adapters.js\");\nconst _hooksclientcontext = __webpack_require__(/*! ../shared/lib/hooks-client-context */ \"./node_modules/next/dist/shared/lib/hooks-client-context.js\");\nconst _onrecoverableerror = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./on-recoverable-error */ \"./node_modules/next/dist/client/on-recoverable-error.js\"));\nconst addChunkSuffix = (getOriginalChunk)=>(chunkId)=>{\n        return getOriginalChunk(chunkId) + (\"\" + ( false ? 0 : \"\"));\n    };\n// ensure dynamic imports have deployment id added if enabled\nconst getChunkScriptFilename = __webpack_require__.u;\n// eslint-disable-next-line no-undef\n__webpack_require__.u = addChunkSuffix(getChunkScriptFilename);\n// eslint-disable-next-line no-undef\nconst getChunkCssFilename = __webpack_require__.k;\n// eslint-disable-next-line no-undef\n__webpack_require__.k = addChunkSuffix(getChunkCssFilename);\n// eslint-disable-next-line no-undef\nconst getMiniCssFilename = __webpack_require__.miniCssF;\n// eslint-disable-next-line no-undef\n__webpack_require__.miniCssF = addChunkSuffix(getMiniCssFilename);\nconst version = \"13.4.12\";\nlet router;\nconst emitter = (0, _mitt.default)();\nconst looseToArray = (input)=>[].slice.call(input);\nlet initialData;\nlet defaultLocale = undefined;\nlet asPath;\nlet pageLoader;\nlet appElement;\nlet headManager;\nlet initialMatchesMiddleware = false;\nlet lastAppProps;\nlet lastRenderReject;\nlet webpackHMR;\nlet CachedApp, onPerfEntry;\nlet CachedComponent;\nself.__next_require__ = __webpack_require__;\nclass Container extends _react.default.Component {\n    componentDidCatch(componentErr, info) {\n        this.props.fn(componentErr, info);\n    }\n    componentDidMount() {\n        this.scrollToHash();\n        // We need to replace the router state if:\n        // - the page was (auto) exported and has a query string or search (hash)\n        // - it was auto exported and is a dynamic route (to provide params)\n        // - if it is a client-side skeleton (fallback render)\n        // - if middleware matches the current page (may have rewrite params)\n        // - if rewrites in next.config.js match (may have rewrite params)\n        if (router.isSsr && (initialData.isFallback || initialData.nextExport && ((0, _isdynamic.isDynamicRoute)(router.pathname) || location.search || false || initialMatchesMiddleware) || initialData.props && initialData.props.__N_SSG && (location.search || false || initialMatchesMiddleware))) {\n            // update query on mount for exported pages\n            router.replace(router.pathname + \"?\" + String((0, _querystring.assign)((0, _querystring.urlQueryToSearchParams)(router.query), new URLSearchParams(location.search))), asPath, {\n                // @ts-ignore\n                // WARNING: `_h` is an internal option for handing Next.js\n                // client-side hydration. Your app should _never_ use this property.\n                // It may change at any time without notice.\n                _h: 1,\n                // Fallback pages must trigger the data fetch, so the transition is\n                // not shallow.\n                // Other pages (strictly updating query) happens shallowly, as data\n                // requirements would already be present.\n                shallow: !initialData.isFallback && !initialMatchesMiddleware\n            }).catch((err)=>{\n                if (!err.cancelled) throw err;\n            });\n        }\n    }\n    componentDidUpdate() {\n        this.scrollToHash();\n    }\n    scrollToHash() {\n        let { hash } = location;\n        hash = hash && hash.substring(1);\n        if (!hash) return;\n        const el = document.getElementById(hash);\n        if (!el) return;\n        // If we call scrollIntoView() in here without a setTimeout\n        // it won't scroll properly.\n        setTimeout(()=>el.scrollIntoView(), 0);\n    }\n    render() {\n        if (false) {} else {\n            const { ReactDevOverlay } = __webpack_require__(/*! next/dist/compiled/@next/react-dev-overlay/dist/client */ \"./node_modules/next/dist/compiled/@next/react-dev-overlay/dist/client.js\");\n            return /*#__PURE__*/ _react.default.createElement(ReactDevOverlay, null, this.props.children);\n        }\n    }\n}\nasync function initialize(opts) {\n    if (opts === void 0) opts = {};\n    // This makes sure this specific lines are removed in production\n    if (true) {\n        webpackHMR = opts.webpackHMR;\n    }\n    initialData = JSON.parse(document.getElementById(\"__NEXT_DATA__\").textContent);\n    window.__NEXT_DATA__ = initialData;\n    defaultLocale = initialData.defaultLocale;\n    const prefix = initialData.assetPrefix || \"\";\n    // With dynamic assetPrefix it's no longer possible to set assetPrefix at the build time\n    // So, this is how we do it in the client side at runtime\n    __webpack_require__.p = \"\" + prefix + \"/_next/\" //eslint-disable-line\n    ;\n    // Initialize next/config with the environment configuration\n    (0, _runtimeconfig.setConfig)({\n        serverRuntimeConfig: {},\n        publicRuntimeConfig: initialData.runtimeConfig || {}\n    });\n    asPath = (0, _utils.getURL)();\n    // make sure not to attempt stripping basePath for 404s\n    if ((0, _hasbasepath.hasBasePath)(asPath)) {\n        asPath = (0, _removebasepath.removeBasePath)(asPath);\n    }\n    if (false) {}\n    if (initialData.scriptLoader) {\n        const { initScriptLoader } = __webpack_require__(/*! ./script */ \"./node_modules/next/dist/client/script.js\");\n        initScriptLoader(initialData.scriptLoader);\n    }\n    pageLoader = new _pageloader.default(initialData.buildId, prefix);\n    const register = (param)=>{\n        let [r, f] = param;\n        return pageLoader.routeLoader.onEntrypoint(r, f);\n    };\n    if (window.__NEXT_P) {\n        // Defer page registration for another tick. This will increase the overall\n        // latency in hydrating the page, but reduce the total blocking time.\n        window.__NEXT_P.map((p)=>setTimeout(()=>register(p), 0));\n    }\n    window.__NEXT_P = [];\n    window.__NEXT_P.push = register;\n    headManager = (0, _headmanager.default)();\n    headManager.getIsSsr = ()=>{\n        return router.isSsr;\n    };\n    appElement = document.getElementById(\"__next\");\n    return {\n        assetPrefix: prefix\n    };\n}\nfunction renderApp(App, appProps) {\n    return /*#__PURE__*/ _react.default.createElement(App, appProps);\n}\nfunction AppContainer(param) {\n    _s();\n    let { children } = param;\n    // Create a memoized value for next/navigation router context.\n    const adaptedForAppRouter = _react.default.useMemo(()=>{\n        return (0, _adapters.adaptForAppRouterInstance)(router);\n    }, []);\n    var _self___NEXT_DATA___autoExport;\n    return /*#__PURE__*/ _react.default.createElement(Container, {\n        fn: (error)=>// eslint-disable-next-line @typescript-eslint/no-use-before-define\n            renderError({\n                App: CachedApp,\n                err: error\n            }).catch((err)=>console.error(\"Error rendering page: \", err))\n    }, /*#__PURE__*/ _react.default.createElement(_approutercontext.AppRouterContext.Provider, {\n        value: adaptedForAppRouter\n    }, /*#__PURE__*/ _react.default.createElement(_hooksclientcontext.SearchParamsContext.Provider, {\n        value: (0, _adapters.adaptForSearchParams)(router)\n    }, /*#__PURE__*/ _react.default.createElement(_adapters.PathnameContextProviderAdapter, {\n        router: router,\n        isAutoExport: (_self___NEXT_DATA___autoExport = self.__NEXT_DATA__.autoExport) != null ? _self___NEXT_DATA___autoExport : false\n    }, /*#__PURE__*/ _react.default.createElement(_routercontext.RouterContext.Provider, {\n        value: (0, _router.makePublicRouterInstance)(router)\n    }, /*#__PURE__*/ _react.default.createElement(_headmanagercontext.HeadManagerContext.Provider, {\n        value: headManager\n    }, /*#__PURE__*/ _react.default.createElement(_imageconfigcontext.ImageConfigContext.Provider, {\n        value: {\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image\",\"loader\":\"default\",\"dangerouslyAllowSVG\":false,\"unoptimized\":false,\"domains\":[],\"remotePatterns\":[]}\n    }, children)))))));\n}\n_s(AppContainer, \"F6BSfrFQNeqenuPnUMVY/6gI8uE=\");\n_c = AppContainer;\nconst wrapApp = (App)=>(wrappedAppProps)=>{\n        const appProps = {\n            ...wrappedAppProps,\n            Component: CachedComponent,\n            err: initialData.err,\n            router\n        };\n        return /*#__PURE__*/ _react.default.createElement(AppContainer, null, renderApp(App, appProps));\n    };\n// This method handles all runtime and debug errors.\n// 404 and 500 errors are special kind of errors\n// and they are still handle via the main render method.\nfunction renderError(renderErrorProps) {\n    let { App, err } = renderErrorProps;\n    // In development runtime errors are caught by our overlay\n    // In production we catch runtime errors using componentDidCatch which will trigger renderError\n    if (true) {\n        // A Next.js rendering runtime error is always unrecoverable\n        // FIXME: let's make this recoverable (error in GIP client-transition)\n        webpackHMR.onUnrecoverableError();\n        // We need to render an empty <App> so that the `<ReactDevOverlay>` can\n        // render itself.\n        // TODO: Fix disabled eslint rule\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return doRender({\n            App: ()=>null,\n            props: {},\n            Component: ()=>null,\n            styleSheets: []\n        });\n    }\n    // Make sure we log the error to the console, otherwise users can't track down issues.\n    console.error(err);\n    console.error(\"A client-side exception has occurred, see here for more info: https://nextjs.org/docs/messages/client-side-exception-occurred\");\n    return pageLoader.loadPage(\"/_error\").then((param)=>{\n        let { page: ErrorComponent, styleSheets } = param;\n        return (lastAppProps == null ? void 0 : lastAppProps.Component) === ErrorComponent ? Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! ../pages/_error */ \"./node_modules/next/dist/pages/_error.js\"))).then((errorModule)=>{\n            return Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! ../pages/_app */ \"./node_modules/next/dist/pages/_app.js\"))).then((appModule)=>{\n                App = appModule.default;\n                renderErrorProps.App = App;\n                return errorModule;\n            });\n        }).then((m)=>({\n                ErrorComponent: m.default,\n                styleSheets: []\n            })) : {\n            ErrorComponent,\n            styleSheets\n        };\n    }).then((param)=>{\n        let { ErrorComponent, styleSheets } = param;\n        var _renderErrorProps_props;\n        // In production we do a normal render with the `ErrorComponent` as component.\n        // If we've gotten here upon initial render, we can use the props from the server.\n        // Otherwise, we need to call `getInitialProps` on `App` before mounting.\n        const AppTree = wrapApp(App);\n        const appCtx = {\n            Component: ErrorComponent,\n            AppTree,\n            router,\n            ctx: {\n                err,\n                pathname: initialData.page,\n                query: initialData.query,\n                asPath,\n                AppTree\n            }\n        };\n        return Promise.resolve(((_renderErrorProps_props = renderErrorProps.props) == null ? void 0 : _renderErrorProps_props.err) ? renderErrorProps.props : (0, _utils.loadGetInitialProps)(App, appCtx)).then((initProps)=>// eslint-disable-next-line @typescript-eslint/no-use-before-define\n            doRender({\n                ...renderErrorProps,\n                err,\n                Component: ErrorComponent,\n                styleSheets,\n                props: initProps\n            }));\n    });\n}\n// Dummy component that we render as a child of Root so that we can\n// toggle the correct styles before the page is rendered.\nfunction Head(param) {\n    _s1();\n    let { callback } = param;\n    // We use `useLayoutEffect` to guarantee the callback is executed\n    // as soon as React flushes the update.\n    _react.default.useLayoutEffect(()=>callback(), [\n        callback\n    ]);\n    return null;\n}\n_s1(Head, \"n7/vCynhJvM+pLkyL2DMQUF0odM=\");\n_c1 = Head;\nlet reactRoot = null;\n// On initial render a hydrate should always happen\nlet shouldHydrate = true;\nfunction clearMarks() {\n    [\n        \"beforeRender\",\n        \"afterHydrate\",\n        \"afterRender\",\n        \"routeChange\"\n    ].forEach((mark)=>performance.clearMarks(mark));\n}\nfunction markHydrateComplete() {\n    if (!_utils.ST) return;\n    performance.mark(\"afterHydrate\") // mark end of hydration\n    ;\n    performance.measure(\"Next.js-before-hydration\", \"navigationStart\", \"beforeRender\");\n    performance.measure(\"Next.js-hydration\", \"beforeRender\", \"afterHydrate\");\n    if (onPerfEntry) {\n        performance.getEntriesByName(\"Next.js-hydration\").forEach(onPerfEntry);\n    }\n    clearMarks();\n}\nfunction markRenderComplete() {\n    if (!_utils.ST) return;\n    performance.mark(\"afterRender\") // mark end of render\n    ;\n    const navStartEntries = performance.getEntriesByName(\"routeChange\", \"mark\");\n    if (!navStartEntries.length) return;\n    performance.measure(\"Next.js-route-change-to-render\", navStartEntries[0].name, \"beforeRender\");\n    performance.measure(\"Next.js-render\", \"beforeRender\", \"afterRender\");\n    if (onPerfEntry) {\n        performance.getEntriesByName(\"Next.js-render\").forEach(onPerfEntry);\n        performance.getEntriesByName(\"Next.js-route-change-to-render\").forEach(onPerfEntry);\n    }\n    clearMarks();\n    [\n        \"Next.js-route-change-to-render\",\n        \"Next.js-render\"\n    ].forEach((measure)=>performance.clearMeasures(measure));\n}\nfunction renderReactElement(domEl, fn) {\n    // mark start of hydrate/render\n    if (_utils.ST) {\n        performance.mark(\"beforeRender\");\n    }\n    const reactEl = fn(shouldHydrate ? markHydrateComplete : markRenderComplete);\n    if (!reactRoot) {\n        // Unlike with createRoot, you don't need a separate root.render() call here\n        reactRoot = _client.default.hydrateRoot(domEl, reactEl, {\n            onRecoverableError: _onrecoverableerror.default\n        });\n        // TODO: Remove shouldHydrate variable when React 18 is stable as it can depend on `reactRoot` existing\n        shouldHydrate = false;\n    } else {\n        const startTransition = _react.default.startTransition;\n        startTransition(()=>{\n            reactRoot.render(reactEl);\n        });\n    }\n}\nfunction Root(param) {\n    _s2();\n    let { callbacks, children } = param;\n    // We use `useLayoutEffect` to guarantee the callbacks are executed\n    // as soon as React flushes the update\n    _react.default.useLayoutEffect(()=>callbacks.forEach((callback)=>callback()), [\n        callbacks\n    ]);\n    // We should ask to measure the Web Vitals after rendering completes so we\n    // don't cause any hydration delay:\n    _react.default.useEffect(()=>{\n        (0, _performancerelayer.default)(onPerfEntry);\n    }, []);\n    if (false) {}\n    return children;\n}\n_s2(Root, \"Gjgl5rfcc2T4sFnfEMfRvL6K4Q4=\");\n_c2 = Root;\nfunction doRender(input) {\n    let { App, Component, props, err } = input;\n    let styleSheets = \"initial\" in input ? undefined : input.styleSheets;\n    Component = Component || lastAppProps.Component;\n    props = props || lastAppProps.props;\n    const appProps = {\n        ...props,\n        Component,\n        err,\n        router\n    };\n    // lastAppProps has to be set before ReactDom.render to account for ReactDom throwing an error.\n    lastAppProps = appProps;\n    let canceled = false;\n    let resolvePromise;\n    const renderPromise = new Promise((resolve, reject)=>{\n        if (lastRenderReject) {\n            lastRenderReject();\n        }\n        resolvePromise = ()=>{\n            lastRenderReject = null;\n            resolve();\n        };\n        lastRenderReject = ()=>{\n            canceled = true;\n            lastRenderReject = null;\n            const error = new Error(\"Cancel rendering route\");\n            error.cancelled = true;\n            reject(error);\n        };\n    });\n    // This function has a return type to ensure it doesn't start returning a\n    // Promise. It should remain synchronous.\n    function onStart() {\n        if (!styleSheets || // We use `style-loader` in development, so we don't need to do anything\n        // unless we're in production:\n        \"development\" !== \"production\") {\n            return false;\n        }\n        const currentStyleTags = looseToArray(document.querySelectorAll(\"style[data-n-href]\"));\n        const currentHrefs = new Set(currentStyleTags.map((tag)=>tag.getAttribute(\"data-n-href\")));\n        const noscript = document.querySelector(\"noscript[data-n-css]\");\n        const nonce = noscript == null ? void 0 : noscript.getAttribute(\"data-n-css\");\n        styleSheets.forEach((param)=>{\n            let { href, text } = param;\n            if (!currentHrefs.has(href)) {\n                const styleTag = document.createElement(\"style\");\n                styleTag.setAttribute(\"data-n-href\", href);\n                styleTag.setAttribute(\"media\", \"x\");\n                if (nonce) {\n                    styleTag.setAttribute(\"nonce\", nonce);\n                }\n                document.head.appendChild(styleTag);\n                styleTag.appendChild(document.createTextNode(text));\n            }\n        });\n        return true;\n    }\n    function onHeadCommit() {\n        if (// unless we're in production:\n        false) {}\n        if (input.scroll) {\n            const { x, y } = input.scroll;\n            (0, _handlesmoothscroll.handleSmoothScroll)(()=>{\n                window.scrollTo(x, y);\n            });\n        }\n    }\n    function onRootCommit() {\n        resolvePromise();\n    }\n    onStart();\n    const elem = /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/ _react.default.createElement(Head, {\n        callback: onHeadCommit\n    }), /*#__PURE__*/ _react.default.createElement(AppContainer, null, renderApp(App, appProps), /*#__PURE__*/ _react.default.createElement(_portal.Portal, {\n        type: \"next-route-announcer\"\n    }, /*#__PURE__*/ _react.default.createElement(_routeannouncer.RouteAnnouncer, null))));\n    // We catch runtime errors using componentDidCatch which will trigger renderError\n    renderReactElement(appElement, (callback)=>/*#__PURE__*/ _react.default.createElement(Root, {\n            callbacks: [\n                callback,\n                onRootCommit\n            ]\n        },  true ? /*#__PURE__*/ _react.default.createElement(_react.default.StrictMode, null, elem) : 0));\n    return renderPromise;\n}\nasync function render(renderingProps) {\n    if (renderingProps.err) {\n        await renderError(renderingProps);\n        return;\n    }\n    try {\n        await doRender(renderingProps);\n    } catch (err) {\n        const renderErr = (0, _iserror.getProperError)(err);\n        // bubble up cancelation errors\n        if (renderErr.cancelled) {\n            throw renderErr;\n        }\n        if (true) {\n            // Ensure this error is displayed in the overlay in development\n            setTimeout(()=>{\n                throw renderErr;\n            });\n        }\n        await renderError({\n            ...renderingProps,\n            err: renderErr\n        });\n    }\n}\nasync function hydrate(opts) {\n    let initialErr = initialData.err;\n    try {\n        const appEntrypoint = await pageLoader.routeLoader.whenEntrypoint(\"/_app\");\n        if (\"error\" in appEntrypoint) {\n            throw appEntrypoint.error;\n        }\n        const { component: app, exports: mod } = appEntrypoint;\n        CachedApp = app;\n        if (mod && mod.reportWebVitals) {\n            onPerfEntry = (param)=>{\n                let { id, name, startTime, value, duration, entryType, entries, attribution } = param;\n                // Combines timestamp with random number for unique ID\n                const uniqueID = Date.now() + \"-\" + (Math.floor(Math.random() * (9e12 - 1)) + 1e12);\n                let perfStartEntry;\n                if (entries && entries.length) {\n                    perfStartEntry = entries[0].startTime;\n                }\n                const webVitals = {\n                    id: id || uniqueID,\n                    name,\n                    startTime: startTime || perfStartEntry,\n                    value: value == null ? duration : value,\n                    label: entryType === \"mark\" || entryType === \"measure\" ? \"custom\" : \"web-vital\"\n                };\n                if (attribution) {\n                    webVitals.attribution = attribution;\n                }\n                mod.reportWebVitals(webVitals);\n            };\n        }\n        const pageEntrypoint = // error, so we need to skip waiting for the entrypoint.\n         true && initialData.err ? {\n            error: initialData.err\n        } : await pageLoader.routeLoader.whenEntrypoint(initialData.page);\n        if (\"error\" in pageEntrypoint) {\n            throw pageEntrypoint.error;\n        }\n        CachedComponent = pageEntrypoint.component;\n        if (true) {\n            const { isValidElementType } = __webpack_require__(/*! next/dist/compiled/react-is */ \"./node_modules/next/dist/compiled/react-is/index.js\");\n            if (!isValidElementType(CachedComponent)) {\n                throw new Error('The default export is not a React Component in page: \"' + initialData.page + '\"');\n            }\n        }\n    } catch (error) {\n        // This catches errors like throwing in the top level of a module\n        initialErr = (0, _iserror.getProperError)(error);\n    }\n    if (true) {\n        const { getServerError } = __webpack_require__(/*! next/dist/compiled/@next/react-dev-overlay/dist/client */ \"./node_modules/next/dist/compiled/@next/react-dev-overlay/dist/client.js\");\n        // Server-side runtime errors need to be re-thrown on the client-side so\n        // that the overlay is rendered.\n        if (initialErr) {\n            if (initialErr === initialData.err) {\n                setTimeout(()=>{\n                    let error;\n                    try {\n                        // Generate a new error object. We `throw` it because some browsers\n                        // will set the `stack` when thrown, and we want to ensure ours is\n                        // not overridden when we re-throw it below.\n                        throw new Error(initialErr.message);\n                    } catch (e) {\n                        error = e;\n                    }\n                    error.name = initialErr.name;\n                    error.stack = initialErr.stack;\n                    throw getServerError(error, initialErr.source);\n                });\n            } else {\n                setTimeout(()=>{\n                    throw initialErr;\n                });\n            }\n        }\n    }\n    if (window.__NEXT_PRELOADREADY) {\n        await window.__NEXT_PRELOADREADY(initialData.dynamicIds);\n    }\n    router = (0, _router.createRouter)(initialData.page, initialData.query, asPath, {\n        initialProps: initialData.props,\n        pageLoader,\n        App: CachedApp,\n        Component: CachedComponent,\n        wrapApp,\n        err: initialErr,\n        isFallback: Boolean(initialData.isFallback),\n        subscription: (info, App, scroll)=>render(Object.assign({}, info, {\n                App,\n                scroll\n            })),\n        locale: initialData.locale,\n        locales: initialData.locales,\n        defaultLocale,\n        domainLocales: initialData.domainLocales,\n        isPreview: initialData.isPreview\n    });\n    initialMatchesMiddleware = await router._initialMatchesMiddlewarePromise;\n    const renderCtx = {\n        App: CachedApp,\n        initial: true,\n        Component: CachedComponent,\n        props: initialData.props,\n        err: initialErr\n    };\n    if (opts == null ? void 0 : opts.beforeRender) {\n        await opts.beforeRender();\n    }\n    render(renderCtx);\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=index.js.map\nvar _c, _c1, _c2;\n$RefreshReg$(_c, \"AppContainer\");\n$RefreshReg$(_c1, \"Head\");\n$RefreshReg$(_c2, \"Root\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxtQkFBbUIsR0FBZ0I7Ozs7OztBQUNuQ0EsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0YsS0FBTUMsQ0FBQUEsQ0FNTjtBQUNBLFNBQVNNLFFBQVFDLE1BQU0sRUFBRUMsR0FBRztJQUN4QixJQUFJLElBQUlDLFFBQVFELElBQUlaLE9BQU9DLGNBQWMsQ0FBQ1UsUUFBUUUsTUFBTTtRQUNwREMsWUFBWTtRQUNaQyxLQUFLSCxHQUFHLENBQUNDLEtBQUs7SUFDbEI7QUFDSjtBQUNBSCxRQUFRUixTQUFTO0lBQ2JHLFNBQVM7UUFDTCxPQUFPQTtJQUNYO0lBQ0FDLFFBQVE7UUFDSixPQUFPQTtJQUNYO0lBQ0FDLFNBQVM7UUFDTCxPQUFPQTtJQUNYO0lBQ0FDLFlBQVk7UUFDUixPQUFPQTtJQUNYO0lBQ0FDLFNBQVM7UUFDTCxPQUFPQTtJQUNYO0FBQ0o7QUFDQSxNQUFNTywyQkFBMkJDLG1CQUFPQSxDQUFDLDRHQUF5QztBQUNsRkEsbUJBQU9BLENBQUMsdUdBQW9DO0FBQzVDLE1BQU1DLFNBQVMsV0FBVyxHQUFHRix5QkFBeUJHLENBQUMsQ0FBQ0YsbUJBQU9BLENBQUMsNENBQU87QUFDdkUsTUFBTUcsVUFBVSxXQUFXLEdBQUdKLHlCQUF5QkcsQ0FBQyxDQUFDRixtQkFBT0EsQ0FBQyw0REFBa0I7QUFDbkYsTUFBTUksc0JBQXNCSixtQkFBT0EsQ0FBQyx1R0FBb0M7QUFDeEUsTUFBTUssUUFBUSxXQUFXLEdBQUdOLHlCQUF5QkcsQ0FBQyxDQUFDRixtQkFBT0EsQ0FBQyx1RUFBb0I7QUFDbkYsTUFBTU0saUJBQWlCTixtQkFBT0EsQ0FBQywyRkFBOEI7QUFDN0QsTUFBTU8sc0JBQXNCUCxtQkFBT0EsQ0FBQyxpSUFBaUQ7QUFDckYsTUFBTVEsYUFBYVIsbUJBQU9BLENBQUMsNkdBQXVDO0FBQ2xFLE1BQU1TLGVBQWVULG1CQUFPQSxD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QVlzTyxRQUFRaFEsWUFBWTBCLFVBQVU7UUFDMUN1TyxjQUFjLENBQUM3TyxNQUFNaUYsS0FBSzBHLFNBQVMxSixPQUFPbEgsT0FBT2lHLE1BQU0sQ0FBQyxDQUFDLEdBQUdoQixNQUFNO2dCQUMxRGlGO2dCQUNBMEc7WUFDSjtRQUNKN0gsUUFBUWxGLFlBQVlrRixNQUFNO1FBQzFCSixTQUFTOUUsWUFBWThFLE9BQU87UUFDNUI3RTtRQUNBaVEsZUFBZWxRLFlBQVlrUSxhQUFhO1FBQ3hDQyxXQUFXblEsWUFBWW1RLFNBQVM7SUFDcEM7SUFDQTVQLDJCQUEyQixNQUFNOUQsT0FBTzJULGdDQUFnQztJQUN4RSxNQUFNQyxZQUFZO1FBQ2RoSyxLQUFLMUY7UUFDTDJQLFNBQVM7UUFDVHJQLFdBQVdKO1FBQ1hRLE9BQU9yQixZQUFZcUIsS0FBSztRQUN4QnNCLEtBQUtvTDtJQUNUO0lBQ0EsSUFBSXRLLFFBQVEsT0FBTyxLQUFLLElBQUlBLEtBQUs4TSxZQUFZLEVBQUU7UUFDM0MsTUFBTTlNLEtBQUs4TSxZQUFZO0lBQzNCO0lBQ0FsTixPQUFPZ047QUFDWDtBQUVBLElBQUksQ0FBQyxPQUFPaFUsUUFBUXNELE9BQU8sS0FBSyxjQUFlLE9BQU90RCxRQUFRc0QsT0FBTyxLQUFLLFlBQVl0RCxRQUFRc0QsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPdEQsUUFBUXNELE9BQU8sQ0FBQzZRLFVBQVUsS0FBSyxhQUFhO0lBQ3JLclUsT0FBT0MsY0FBYyxDQUFDQyxRQUFRc0QsT0FBTyxFQUFFLGNBQWM7UUFBRXJELE9BQU87SUFBSztJQUNuRUgsT0FBT2lHLE1BQU0sQ0FBQy9GLFFBQVFzRCxPQUFPLEVBQUV0RDtJQUMvQkUsT0FBT0YsT0FBTyxHQUFHQSxRQUFRc0QsT0FBTztBQUNsQyxFQUVBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9pbmRleC5qcz80NmNiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGdsb2JhbCBsb2NhdGlvbiAqLyBcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICAgIHZlcnNpb246IG51bGwsXG4gICAgcm91dGVyOiBudWxsLFxuICAgIGVtaXR0ZXI6IG51bGwsXG4gICAgaW5pdGlhbGl6ZTogbnVsbCxcbiAgICBoeWRyYXRlOiBudWxsXG59KTtcbmZ1bmN0aW9uIF9leHBvcnQodGFyZ2V0LCBhbGwpIHtcbiAgICBmb3IodmFyIG5hbWUgaW4gYWxsKU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBhbGxbbmFtZV1cbiAgICB9KTtcbn1cbl9leHBvcnQoZXhwb3J0cywge1xuICAgIHZlcnNpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdmVyc2lvbjtcbiAgICB9LFxuICAgIHJvdXRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiByb3V0ZXI7XG4gICAgfSxcbiAgICBlbWl0dGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGVtaXR0ZXI7XG4gICAgfSxcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGluaXRpYWxpemU7XG4gICAgfSxcbiAgICBoeWRyYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGh5ZHJhdGU7XG4gICAgfVxufSk7XG5jb25zdCBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL18vX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0XCIpO1xucmVxdWlyZShcIi4uL2J1aWxkL3BvbHlmaWxscy9wb2x5ZmlsbC1tb2R1bGVcIik7XG5jb25zdCBfcmVhY3QgPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5fKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5jb25zdCBfY2xpZW50ID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuXyhyZXF1aXJlKFwicmVhY3QtZG9tL2NsaWVudFwiKSk7XG5jb25zdCBfaGVhZG1hbmFnZXJjb250ZXh0ID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvaGVhZC1tYW5hZ2VyLWNvbnRleHRcIik7XG5jb25zdCBfbWl0dCA9IC8qI19fUFVSRV9fKi8gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0Ll8ocmVxdWlyZShcIi4uL3NoYXJlZC9saWIvbWl0dFwiKSk7XG5jb25zdCBfcm91dGVyY29udGV4dCA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci1jb250ZXh0XCIpO1xuY29uc3QgX2hhbmRsZXNtb290aHNjcm9sbCA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9oYW5kbGUtc21vb3RoLXNjcm9sbFwiKTtcbmNvbnN0IF9pc2R5bmFtaWMgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaXMtZHluYW1pY1wiKTtcbmNvbnN0IF9xdWVyeXN0cmluZyA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9xdWVyeXN0cmluZ1wiKTtcbmNvbnN0IF9ydW50aW1lY29uZmlnID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcnVudGltZS1jb25maWdcIik7XG5jb25zdCBfdXRpbHMgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi91dGlsc1wiKTtcbmNvbnN0IF9wb3J0YWwgPSByZXF1aXJlKFwiLi9wb3J0YWxcIik7XG5jb25zdCBfaGVhZG1hbmFnZXIgPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5fKHJlcXVpcmUoXCIuL2hlYWQtbWFuYWdlclwiKSk7XG5jb25zdCBfcGFnZWxvYWRlciA9IC8qI19fUFVSRV9fKi8gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0Ll8ocmVxdWlyZShcIi4vcGFnZS1sb2FkZXJcIikpO1xuY29uc3QgX3BlcmZvcm1hbmNlcmVsYXllciA9IC8qI19fUFVSRV9fKi8gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0Ll8ocmVxdWlyZShcIi4vcGVyZm9ybWFuY2UtcmVsYXllclwiKSk7XG5jb25zdCBfcm91dGVhbm5vdW5jZXIgPSByZXF1aXJlKFwiLi9yb3V0ZS1hbm5vdW5jZXJcIik7XG5jb25zdCBfcm91dGVyID0gcmVxdWlyZShcIi4vcm91dGVyXCIpO1xuY29uc3QgX2lzZXJyb3IgPSByZXF1aXJlKFwiLi4vbGliL2lzLWVycm9yXCIpO1xuY29uc3QgX2ltYWdlY29uZmlnY29udGV4dCA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL2ltYWdlLWNvbmZpZy1jb250ZXh0XCIpO1xuY29uc3QgX3JlbW92ZWJhc2VwYXRoID0gcmVxdWlyZShcIi4vcmVtb3ZlLWJhc2UtcGF0aFwiKTtcbmNvbnN0IF9oYXNiYXNlcGF0aCA9IHJlcXVpcmUoXCIuL2hhcy1iYXNlLXBhdGhcIik7XG5jb25zdCBfYXBwcm91dGVyY29udGV4dCA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dFwiKTtcbmNvbnN0IF9hZGFwdGVycyA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci9hZGFwdGVyc1wiKTtcbmNvbnN0IF9ob29rc2NsaWVudGNvbnRleHQgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9ob29rcy1jbGllbnQtY29udGV4dFwiKTtcbmNvbnN0IF9vbnJlY292ZXJhYmxlZXJyb3IgPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5fKHJlcXVpcmUoXCIuL29uLXJlY292ZXJhYmxlLWVycm9yXCIpKTtcbmNvbnN0IGFkZENodW5rU3VmZml4ID0gKGdldE9yaWdpbmFsQ2h1bmspPT4oY2h1bmtJZCk9PntcbiAgICAgICAgcmV0dXJuIGdldE9yaWdpbmFsQ2h1bmsoY2h1bmtJZCkgKyAoXCJcIiArIChwcm9jZXNzLmVudi5ORVhUX0RFUExPWU1FTlRfSUQgPyBcIj9kcGw9XCIgKyBwcm9jZXNzLmVudi5ORVhUX0RFUExPWU1FTlRfSUQgOiBcIlwiKSk7XG4gICAgfTtcbi8vIGVuc3VyZSBkeW5hbWljIGltcG9ydHMgaGF2ZSBkZXBsb3ltZW50IGlkIGFkZGVkIGlmIGVuYWJsZWRcbmNvbnN0IGdldENodW5rU2NyaXB0RmlsZW5hbWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLnU7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbl9fd2VicGFja19yZXF1aXJlX18udSA9IGFkZENodW5rU3VmZml4KGdldENodW5rU2NyaXB0RmlsZW5hbWUpO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG5jb25zdCBnZXRDaHVua0Nzc0ZpbGVuYW1lID0gX193ZWJwYWNrX3JlcXVpcmVfXy5rO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmsgPSBhZGRDaHVua1N1ZmZpeChnZXRDaHVua0Nzc0ZpbGVuYW1lKTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuY29uc3QgZ2V0TWluaUNzc0ZpbGVuYW1lID0gX193ZWJwYWNrX3JlcXVpcmVfXy5taW5pQ3NzRjtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuX193ZWJwYWNrX3JlcXVpcmVfXy5taW5pQ3NzRiA9IGFkZENodW5rU3VmZml4KGdldE1pbmlDc3NGaWxlbmFtZSk7XG5jb25zdCB2ZXJzaW9uID0gXCIxMy40LjEyXCI7XG5sZXQgcm91dGVyO1xuY29uc3QgZW1pdHRlciA9ICgwLCBfbWl0dC5kZWZhdWx0KSgpO1xuY29uc3QgbG9vc2VUb0FycmF5ID0gKGlucHV0KT0+W10uc2xpY2UuY2FsbChpbnB1dCk7XG5sZXQgaW5pdGlhbERhdGE7XG5sZXQgZGVmYXVsdExvY2FsZSA9IHVuZGVmaW5lZDtcbmxldCBhc1BhdGg7XG5sZXQgcGFnZUxvYWRlcjtcbmxldCBhcHBFbGVtZW50O1xubGV0IGhlYWRNYW5hZ2VyO1xubGV0IGluaXRpYWxNYXRjaGVzTWlkZGxld2FyZSA9IGZhbHNlO1xubGV0IGxhc3RBcHBQcm9wcztcbmxldCBsYXN0UmVuZGVyUmVqZWN0O1xubGV0IHdlYnBhY2tITVI7XG5sZXQgQ2FjaGVkQXBwLCBvblBlcmZFbnRyeTtcbmxldCBDYWNoZWRDb21wb25lbnQ7XG5zZWxmLl9fbmV4dF9yZXF1aXJlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fO1xuY2xhc3MgQ29udGFpbmVyIGV4dGVuZHMgX3JlYWN0LmRlZmF1bHQuQ29tcG9uZW50IHtcbiAgICBjb21wb25lbnREaWRDYXRjaChjb21wb25lbnRFcnIsIGluZm8pIHtcbiAgICAgICAgdGhpcy5wcm9wcy5mbihjb21wb25lbnRFcnIsIGluZm8pO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxUb0hhc2goKTtcbiAgICAgICAgLy8gV2UgbmVlZCB0byByZXBsYWNlIHRoZSByb3V0ZXIgc3RhdGUgaWY6XG4gICAgICAgIC8vIC0gdGhlIHBhZ2Ugd2FzIChhdXRvKSBleHBvcnRlZCBhbmQgaGFzIGEgcXVlcnkgc3RyaW5nIG9yIHNlYXJjaCAoaGFzaClcbiAgICAgICAgLy8gLSBpdCB3YXMgYXV0byBleHBvcnRlZCBhbmQgaXMgYSBkeW5hbWljIHJvdXRlICh0byBwcm92aWRlIHBhcmFtcylcbiAgICAgICAgLy8gLSBpZiBpdCBpcyBhIGNsaWVudC1zaWRlIHNrZWxldG9uIChmYWxsYmFjayByZW5kZXIpXG4gICAgICAgIC8vIC0gaWYgbWlkZGxld2FyZSBtYXRjaGVzIHRoZSBjdXJyZW50IHBhZ2UgKG1heSBoYXZlIHJld3JpdGUgcGFyYW1zKVxuICAgICAgICAvLyAtIGlmIHJld3JpdGVzIGluIG5leHQuY29uZmlnLmpzIG1hdGNoIChtYXkgaGF2ZSByZXdyaXRlIHBhcmFtcylcbiAgICAgICAgaWYgKHJvdXRlci5pc1NzciAmJiAoaW5pdGlhbERhdGEuaXNGYWxsYmFjayB8fCBpbml0aWFsRGF0YS5uZXh0RXhwb3J0ICYmICgoMCwgX2lzZHluYW1pYy5pc0R5bmFtaWNSb3V0ZSkocm91dGVyLnBhdGhuYW1lKSB8fCBsb2NhdGlvbi5zZWFyY2ggfHwgcHJvY2Vzcy5lbnYuX19ORVhUX0hBU19SRVdSSVRFUyB8fCBpbml0aWFsTWF0Y2hlc01pZGRsZXdhcmUpIHx8IGluaXRpYWxEYXRhLnByb3BzICYmIGluaXRpYWxEYXRhLnByb3BzLl9fTl9TU0cgJiYgKGxvY2F0aW9uLnNlYXJjaCB8fCBwcm9jZXNzLmVudi5fX05FWFRfSEFTX1JFV1JJVEVTIHx8IGluaXRpYWxNYXRjaGVzTWlkZGxld2FyZSkpKSB7XG4gICAgICAgICAgICAvLyB1cGRhdGUgcXVlcnkgb24gbW91bnQgZm9yIGV4cG9ydGVkIHBhZ2VzXG4gICAgICAgICAgICByb3V0ZXIucmVwbGFjZShyb3V0ZXIucGF0aG5hbWUgKyBcIj9cIiArIFN0cmluZygoMCwgX3F1ZXJ5c3RyaW5nLmFzc2lnbikoKDAsIF9xdWVyeXN0cmluZy51cmxRdWVyeVRvU2VhcmNoUGFyYW1zKShyb3V0ZXIucXVlcnkpLCBuZXcgVVJMU2VhcmNoUGFyYW1zKGxvY2F0aW9uLnNlYXJjaCkpKSwgYXNQYXRoLCB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIC8vIFdBUk5JTkc6IGBfaGAgaXMgYW4gaW50ZXJuYWwgb3B0aW9uIGZvciBoYW5kaW5nIE5leHQuanNcbiAgICAgICAgICAgICAgICAvLyBjbGllbnQtc2lkZSBoeWRyYXRpb24uIFlvdXIgYXBwIHNob3VsZCBfbmV2ZXJfIHVzZSB0aGlzIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIC8vIEl0IG1heSBjaGFuZ2UgYXQgYW55IHRpbWUgd2l0aG91dCBub3RpY2UuXG4gICAgICAgICAgICAgICAgX2g6IDEsXG4gICAgICAgICAgICAgICAgLy8gRmFsbGJhY2sgcGFnZXMgbXVzdCB0cmlnZ2VyIHRoZSBkYXRhIGZldGNoLCBzbyB0aGUgdHJhbnNpdGlvbiBpc1xuICAgICAgICAgICAgICAgIC8vIG5vdCBzaGFsbG93LlxuICAgICAgICAgICAgICAgIC8vIE90aGVyIHBhZ2VzIChzdHJpY3RseSB1cGRhdGluZyBxdWVyeSkgaGFwcGVucyBzaGFsbG93bHksIGFzIGRhdGFcbiAgICAgICAgICAgICAgICAvLyByZXF1aXJlbWVudHMgd291bGQgYWxyZWFkeSBiZSBwcmVzZW50LlxuICAgICAgICAgICAgICAgIHNoYWxsb3c6ICFpbml0aWFsRGF0YS5pc0ZhbGxiYWNrICYmICFpbml0aWFsTWF0Y2hlc01pZGRsZXdhcmVcbiAgICAgICAgICAgIH0pLmNhdGNoKChlcnIpPT57XG4gICAgICAgICAgICAgICAgaWYgKCFlcnIuY2FuY2VsbGVkKSB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsVG9IYXNoKCk7XG4gICAgfVxuICAgIHNjcm9sbFRvSGFzaCgpIHtcbiAgICAgICAgbGV0IHsgaGFzaCAgfSA9IGxvY2F0aW9uO1xuICAgICAgICBoYXNoID0gaGFzaCAmJiBoYXNoLnN1YnN0cmluZygxKTtcbiAgICAgICAgaWYgKCFoYXNoKSByZXR1cm47XG4gICAgICAgIGNvbnN0IGVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaGFzaCk7XG4gICAgICAgIGlmICghZWwpIHJldHVybjtcbiAgICAgICAgLy8gSWYgd2UgY2FsbCBzY3JvbGxJbnRvVmlldygpIGluIGhlcmUgd2l0aG91dCBhIHNldFRpbWVvdXRcbiAgICAgICAgLy8gaXQgd29uJ3Qgc2Nyb2xsIHByb3Blcmx5LlxuICAgICAgICBzZXRUaW1lb3V0KCgpPT5lbC5zY3JvbGxJbnRvVmlldygpLCAwKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHsgUmVhY3REZXZPdmVybGF5ICB9ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9kaXN0L2NsaWVudFwiKTtcbiAgICAgICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoUmVhY3REZXZPdmVybGF5LCBudWxsLCB0aGlzLnByb3BzLmNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGluaXRpYWxpemUob3B0cykge1xuICAgIGlmIChvcHRzID09PSB2b2lkIDApIG9wdHMgPSB7fTtcbiAgICAvLyBUaGlzIG1ha2VzIHN1cmUgdGhpcyBzcGVjaWZpYyBsaW5lcyBhcmUgcmVtb3ZlZCBpbiBwcm9kdWN0aW9uXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIpIHtcbiAgICAgICAgd2VicGFja0hNUiA9IG9wdHMud2VicGFja0hNUjtcbiAgICB9XG4gICAgaW5pdGlhbERhdGEgPSBKU09OLnBhcnNlKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiX19ORVhUX0RBVEFfX1wiKS50ZXh0Q29udGVudCk7XG4gICAgd2luZG93Ll9fTkVYVF9EQVRBX18gPSBpbml0aWFsRGF0YTtcbiAgICBkZWZhdWx0TG9jYWxlID0gaW5pdGlhbERhdGEuZGVmYXVsdExvY2FsZTtcbiAgICBjb25zdCBwcmVmaXggPSBpbml0aWFsRGF0YS5hc3NldFByZWZpeCB8fCBcIlwiO1xuICAgIC8vIFdpdGggZHluYW1pYyBhc3NldFByZWZpeCBpdCdzIG5vIGxvbmdlciBwb3NzaWJsZSB0byBzZXQgYXNzZXRQcmVmaXggYXQgdGhlIGJ1aWxkIHRpbWVcbiAgICAvLyBTbywgdGhpcyBpcyBob3cgd2UgZG8gaXQgaW4gdGhlIGNsaWVudCBzaWRlIGF0IHJ1bnRpbWVcbiAgICBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyA9IFwiXCIgKyBwcmVmaXggKyBcIi9fbmV4dC9cIiAvL2VzbGludC1kaXNhYmxlLWxpbmVcbiAgICA7XG4gICAgLy8gSW5pdGlhbGl6ZSBuZXh0L2NvbmZpZyB3aXRoIHRoZSBlbnZpcm9ubWVudCBjb25maWd1cmF0aW9uXG4gICAgKDAsIF9ydW50aW1lY29uZmlnLnNldENvbmZpZykoe1xuICAgICAgICBzZXJ2ZXJSdW50aW1lQ29uZmlnOiB7fSxcbiAgICAgICAgcHVibGljUnVudGltZUNvbmZpZzogaW5pdGlhbERhdGEucnVudGltZUNvbmZpZyB8fCB7fVxuICAgIH0pO1xuICAgIGFzUGF0aCA9ICgwLCBfdXRpbHMuZ2V0VVJMKSgpO1xuICAgIC8vIG1ha2Ugc3VyZSBub3QgdG8gYXR0ZW1wdCBzdHJpcHBpbmcgYmFzZVBhdGggZm9yIDQwNHNcbiAgICBpZiAoKDAsIF9oYXNiYXNlcGF0aC5oYXNCYXNlUGF0aCkoYXNQYXRoKSkge1xuICAgICAgICBhc1BhdGggPSAoMCwgX3JlbW92ZWJhc2VwYXRoLnJlbW92ZUJhc2VQYXRoKShhc1BhdGgpO1xuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICBjb25zdCB7IG5vcm1hbGl6ZUxvY2FsZVBhdGggIH0gPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9pMThuL25vcm1hbGl6ZS1sb2NhbGUtcGF0aFwiKTtcbiAgICAgICAgY29uc3QgeyBkZXRlY3REb21haW5Mb2NhbGUgIH0gPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9pMThuL2RldGVjdC1kb21haW4tbG9jYWxlXCIpO1xuICAgICAgICBjb25zdCB7IHBhcnNlUmVsYXRpdmVVcmwgIH0gPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcGFyc2UtcmVsYXRpdmUtdXJsXCIpO1xuICAgICAgICBjb25zdCB7IGZvcm1hdFVybCAgfSA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9mb3JtYXQtdXJsXCIpO1xuICAgICAgICBpZiAoaW5pdGlhbERhdGEubG9jYWxlcykge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkQXMgPSBwYXJzZVJlbGF0aXZlVXJsKGFzUGF0aCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbGVQYXRoUmVzdWx0ID0gbm9ybWFsaXplTG9jYWxlUGF0aChwYXJzZWRBcy5wYXRobmFtZSwgaW5pdGlhbERhdGEubG9jYWxlcyk7XG4gICAgICAgICAgICBpZiAobG9jYWxlUGF0aFJlc3VsdC5kZXRlY3RlZExvY2FsZSkge1xuICAgICAgICAgICAgICAgIHBhcnNlZEFzLnBhdGhuYW1lID0gbG9jYWxlUGF0aFJlc3VsdC5wYXRobmFtZTtcbiAgICAgICAgICAgICAgICBhc1BhdGggPSBmb3JtYXRVcmwocGFyc2VkQXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBkZXJpdmUgdGhlIGRlZmF1bHQgbG9jYWxlIGlmIGl0IHdhc24ndCBkZXRlY3RlZCBpbiB0aGUgYXNQYXRoXG4gICAgICAgICAgICAgICAgLy8gc2luY2Ugd2UgZG9uJ3QgcHJlcmVuZGVyIHN0YXRpYyBwYWdlcyB3aXRoIGFsbCBwb3NzaWJsZSBkZWZhdWx0XG4gICAgICAgICAgICAgICAgLy8gbG9jYWxlc1xuICAgICAgICAgICAgICAgIGRlZmF1bHRMb2NhbGUgPSBpbml0aWFsRGF0YS5sb2NhbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhdHRlbXB0IGRldGVjdGluZyBkZWZhdWx0IGxvY2FsZSBiYXNlZCBvbiBob3N0bmFtZVxuICAgICAgICAgICAgY29uc3QgZGV0ZWN0ZWREb21haW4gPSBkZXRlY3REb21haW5Mb2NhbGUocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fRE9NQUlOUywgd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lKTtcbiAgICAgICAgICAgIC8vIFRPRE86IGludmVzdGlnYXRlIGlmIGRlZmF1bHRMb2NhbGUgbmVlZHMgdG8gYmUgcG9wdWxhdGVkIGFmdGVyXG4gICAgICAgICAgICAvLyBoeWRyYXRpb24gdG8gcHJldmVudCBtaXNtYXRjaGVkIHJlbmRlcnNcbiAgICAgICAgICAgIGlmIChkZXRlY3RlZERvbWFpbikge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRMb2NhbGUgPSBkZXRlY3RlZERvbWFpbi5kZWZhdWx0TG9jYWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpbml0aWFsRGF0YS5zY3JpcHRMb2FkZXIpIHtcbiAgICAgICAgY29uc3QgeyBpbml0U2NyaXB0TG9hZGVyICB9ID0gcmVxdWlyZShcIi4vc2NyaXB0XCIpO1xuICAgICAgICBpbml0U2NyaXB0TG9hZGVyKGluaXRpYWxEYXRhLnNjcmlwdExvYWRlcik7XG4gICAgfVxuICAgIHBhZ2VMb2FkZXIgPSBuZXcgX3BhZ2Vsb2FkZXIuZGVmYXVsdChpbml0aWFsRGF0YS5idWlsZElkLCBwcmVmaXgpO1xuICAgIGNvbnN0IHJlZ2lzdGVyID0gKHBhcmFtKT0+e1xuICAgICAgICBsZXQgW3IsIGZdID0gcGFyYW07XG4gICAgICAgIHJldHVybiBwYWdlTG9hZGVyLnJvdXRlTG9hZGVyLm9uRW50cnlwb2ludChyLCBmKTtcbiAgICB9O1xuICAgIGlmICh3aW5kb3cuX19ORVhUX1ApIHtcbiAgICAgICAgLy8gRGVmZXIgcGFnZSByZWdpc3RyYXRpb24gZm9yIGFub3RoZXIgdGljay4gVGhpcyB3aWxsIGluY3JlYXNlIHRoZSBvdmVyYWxsXG4gICAgICAgIC8vIGxhdGVuY3kgaW4gaHlkcmF0aW5nIHRoZSBwYWdlLCBidXQgcmVkdWNlIHRoZSB0b3RhbCBibG9ja2luZyB0aW1lLlxuICAgICAgICB3aW5kb3cuX19ORVhUX1AubWFwKChwKT0+c2V0VGltZW91dCgoKT0+cmVnaXN0ZXIocCksIDApKTtcbiAgICB9XG4gICAgd2luZG93Ll9fTkVYVF9QID0gW107XG4gICAgd2luZG93Ll9fTkVYVF9QLnB1c2ggPSByZWdpc3RlcjtcbiAgICBoZWFkTWFuYWdlciA9ICgwLCBfaGVhZG1hbmFnZXIuZGVmYXVsdCkoKTtcbiAgICBoZWFkTWFuYWdlci5nZXRJc1NzciA9ICgpPT57XG4gICAgICAgIHJldHVybiByb3V0ZXIuaXNTc3I7XG4gICAgfTtcbiAgICBhcHBFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJfX25leHRcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYXNzZXRQcmVmaXg6IHByZWZpeFxuICAgIH07XG59XG5mdW5jdGlvbiByZW5kZXJBcHAoQXBwLCBhcHBQcm9wcykge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoQXBwLCBhcHBQcm9wcyk7XG59XG5mdW5jdGlvbiBBcHBDb250YWluZXIocGFyYW0pIHtcbiAgICBsZXQgeyBjaGlsZHJlbiAgfSA9IHBhcmFtO1xuICAgIC8vIENyZWF0ZSBhIG1lbW9pemVkIHZhbHVlIGZvciBuZXh0L25hdmlnYXRpb24gcm91dGVyIGNvbnRleHQuXG4gICAgY29uc3QgYWRhcHRlZEZvckFwcFJvdXRlciA9IF9yZWFjdC5kZWZhdWx0LnVzZU1lbW8oKCk9PntcbiAgICAgICAgcmV0dXJuICgwLCBfYWRhcHRlcnMuYWRhcHRGb3JBcHBSb3V0ZXJJbnN0YW5jZSkocm91dGVyKTtcbiAgICB9LCBbXSk7XG4gICAgdmFyIF9zZWxmX19fTkVYVF9EQVRBX19fYXV0b0V4cG9ydDtcbiAgICByZXR1cm4gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KENvbnRhaW5lciwge1xuICAgICAgICBmbjogKGVycm9yKT0+Ly8gVE9ETzogRml4IGRpc2FibGVkIGVzbGludCBydWxlXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgICAgICByZW5kZXJFcnJvcih7XG4gICAgICAgICAgICAgICAgQXBwOiBDYWNoZWRBcHAsXG4gICAgICAgICAgICAgICAgZXJyOiBlcnJvclxuICAgICAgICAgICAgfSkuY2F0Y2goKGVycik9PmNvbnNvbGUuZXJyb3IoXCJFcnJvciByZW5kZXJpbmcgcGFnZTogXCIsIGVycikpXG4gICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9hcHByb3V0ZXJjb250ZXh0LkFwcFJvdXRlckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IGFkYXB0ZWRGb3JBcHBSb3V0ZXJcbiAgICB9LCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX2hvb2tzY2xpZW50Y29udGV4dC5TZWFyY2hQYXJhbXNDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiAoMCwgX2FkYXB0ZXJzLmFkYXB0Rm9yU2VhcmNoUGFyYW1zKShyb3V0ZXIpXG4gICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9hZGFwdGVycy5QYXRobmFtZUNvbnRleHRQcm92aWRlckFkYXB0ZXIsIHtcbiAgICAgICAgcm91dGVyOiByb3V0ZXIsXG4gICAgICAgIGlzQXV0b0V4cG9ydDogKF9zZWxmX19fTkVYVF9EQVRBX19fYXV0b0V4cG9ydCA9IHNlbGYuX19ORVhUX0RBVEFfXy5hdXRvRXhwb3J0KSAhPSBudWxsID8gX3NlbGZfX19ORVhUX0RBVEFfX19hdXRvRXhwb3J0IDogZmFsc2VcbiAgICB9LCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JvdXRlcmNvbnRleHQuUm91dGVyQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZTogKDAsIF9yb3V0ZXIubWFrZVB1YmxpY1JvdXRlckluc3RhbmNlKShyb3V0ZXIpXG4gICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9oZWFkbWFuYWdlcmNvbnRleHQuSGVhZE1hbmFnZXJDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiBoZWFkTWFuYWdlclxuICAgIH0sIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfaW1hZ2Vjb25maWdjb250ZXh0LkltYWdlQ29uZmlnQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZTogcHJvY2Vzcy5lbnYuX19ORVhUX0lNQUdFX09QVFNcbiAgICB9LCBjaGlsZHJlbikpKSkpKSk7XG59XG5jb25zdCB3cmFwQXBwID0gKEFwcCk9Pih3cmFwcGVkQXBwUHJvcHMpPT57XG4gICAgICAgIGNvbnN0IGFwcFByb3BzID0ge1xuICAgICAgICAgICAgLi4ud3JhcHBlZEFwcFByb3BzLFxuICAgICAgICAgICAgQ29tcG9uZW50OiBDYWNoZWRDb21wb25lbnQsXG4gICAgICAgICAgICBlcnI6IGluaXRpYWxEYXRhLmVycixcbiAgICAgICAgICAgIHJvdXRlclxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KEFwcENvbnRhaW5lciwgbnVsbCwgcmVuZGVyQXBwKEFwcCwgYXBwUHJvcHMpKTtcbiAgICB9O1xuLy8gVGhpcyBtZXRob2QgaGFuZGxlcyBhbGwgcnVudGltZSBhbmQgZGVidWcgZXJyb3JzLlxuLy8gNDA0IGFuZCA1MDAgZXJyb3JzIGFyZSBzcGVjaWFsIGtpbmQgb2YgZXJyb3JzXG4vLyBhbmQgdGhleSBhcmUgc3RpbGwgaGFuZGxlIHZpYSB0aGUgbWFpbiByZW5kZXIgbWV0aG9kLlxuZnVuY3Rpb24gcmVuZGVyRXJyb3IocmVuZGVyRXJyb3JQcm9wcykge1xuICAgIGxldCB7IEFwcCAsIGVyciAgfSA9IHJlbmRlckVycm9yUHJvcHM7XG4gICAgLy8gSW4gZGV2ZWxvcG1lbnQgcnVudGltZSBlcnJvcnMgYXJlIGNhdWdodCBieSBvdXIgb3ZlcmxheVxuICAgIC8vIEluIHByb2R1Y3Rpb24gd2UgY2F0Y2ggcnVudGltZSBlcnJvcnMgdXNpbmcgY29tcG9uZW50RGlkQ2F0Y2ggd2hpY2ggd2lsbCB0cmlnZ2VyIHJlbmRlckVycm9yXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAvLyBBIE5leHQuanMgcmVuZGVyaW5nIHJ1bnRpbWUgZXJyb3IgaXMgYWx3YXlzIHVucmVjb3ZlcmFibGVcbiAgICAgICAgLy8gRklYTUU6IGxldCdzIG1ha2UgdGhpcyByZWNvdmVyYWJsZSAoZXJyb3IgaW4gR0lQIGNsaWVudC10cmFuc2l0aW9uKVxuICAgICAgICB3ZWJwYWNrSE1SLm9uVW5yZWNvdmVyYWJsZUVycm9yKCk7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gcmVuZGVyIGFuIGVtcHR5IDxBcHA+IHNvIHRoYXQgdGhlIGA8UmVhY3REZXZPdmVybGF5PmAgY2FuXG4gICAgICAgIC8vIHJlbmRlciBpdHNlbGYuXG4gICAgICAgIC8vIFRPRE86IEZpeCBkaXNhYmxlZCBlc2xpbnQgcnVsZVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgIHJldHVybiBkb1JlbmRlcih7XG4gICAgICAgICAgICBBcHA6ICgpPT5udWxsLFxuICAgICAgICAgICAgcHJvcHM6IHt9LFxuICAgICAgICAgICAgQ29tcG9uZW50OiAoKT0+bnVsbCxcbiAgICAgICAgICAgIHN0eWxlU2hlZXRzOiBbXVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gTWFrZSBzdXJlIHdlIGxvZyB0aGUgZXJyb3IgdG8gdGhlIGNvbnNvbGUsIG90aGVyd2lzZSB1c2VycyBjYW4ndCB0cmFjayBkb3duIGlzc3Vlcy5cbiAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgY29uc29sZS5lcnJvcihcIkEgY2xpZW50LXNpZGUgZXhjZXB0aW9uIGhhcyBvY2N1cnJlZCwgc2VlIGhlcmUgZm9yIG1vcmUgaW5mbzogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvY2xpZW50LXNpZGUtZXhjZXB0aW9uLW9jY3VycmVkXCIpO1xuICAgIHJldHVybiBwYWdlTG9hZGVyLmxvYWRQYWdlKFwiL19lcnJvclwiKS50aGVuKChwYXJhbSk9PntcbiAgICAgICAgbGV0IHsgcGFnZTogRXJyb3JDb21wb25lbnQgLCBzdHlsZVNoZWV0cyAgfSA9IHBhcmFtO1xuICAgICAgICByZXR1cm4gKGxhc3RBcHBQcm9wcyA9PSBudWxsID8gdm9pZCAwIDogbGFzdEFwcFByb3BzLkNvbXBvbmVudCkgPT09IEVycm9yQ29tcG9uZW50ID8gaW1wb3J0KFwiLi4vcGFnZXMvX2Vycm9yXCIpLnRoZW4oKGVycm9yTW9kdWxlKT0+e1xuICAgICAgICAgICAgcmV0dXJuIGltcG9ydChcIi4uL3BhZ2VzL19hcHBcIikudGhlbigoYXBwTW9kdWxlKT0+e1xuICAgICAgICAgICAgICAgIEFwcCA9IGFwcE1vZHVsZS5kZWZhdWx0O1xuICAgICAgICAgICAgICAgIHJlbmRlckVycm9yUHJvcHMuQXBwID0gQXBwO1xuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvck1vZHVsZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KS50aGVuKChtKT0+KHtcbiAgICAgICAgICAgICAgICBFcnJvckNvbXBvbmVudDogbS5kZWZhdWx0LFxuICAgICAgICAgICAgICAgIHN0eWxlU2hlZXRzOiBbXVxuICAgICAgICAgICAgfSkpIDoge1xuICAgICAgICAgICAgRXJyb3JDb21wb25lbnQsXG4gICAgICAgICAgICBzdHlsZVNoZWV0c1xuICAgICAgICB9O1xuICAgIH0pLnRoZW4oKHBhcmFtKT0+e1xuICAgICAgICBsZXQgeyBFcnJvckNvbXBvbmVudCAsIHN0eWxlU2hlZXRzICB9ID0gcGFyYW07XG4gICAgICAgIHZhciBfcmVuZGVyRXJyb3JQcm9wc19wcm9wcztcbiAgICAgICAgLy8gSW4gcHJvZHVjdGlvbiB3ZSBkbyBhIG5vcm1hbCByZW5kZXIgd2l0aCB0aGUgYEVycm9yQ29tcG9uZW50YCBhcyBjb21wb25lbnQuXG4gICAgICAgIC8vIElmIHdlJ3ZlIGdvdHRlbiBoZXJlIHVwb24gaW5pdGlhbCByZW5kZXIsIHdlIGNhbiB1c2UgdGhlIHByb3BzIGZyb20gdGhlIHNlcnZlci5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSBuZWVkIHRvIGNhbGwgYGdldEluaXRpYWxQcm9wc2Agb24gYEFwcGAgYmVmb3JlIG1vdW50aW5nLlxuICAgICAgICBjb25zdCBBcHBUcmVlID0gd3JhcEFwcChBcHApO1xuICAgICAgICBjb25zdCBhcHBDdHggPSB7XG4gICAgICAgICAgICBDb21wb25lbnQ6IEVycm9yQ29tcG9uZW50LFxuICAgICAgICAgICAgQXBwVHJlZSxcbiAgICAgICAgICAgIHJvdXRlcixcbiAgICAgICAgICAgIGN0eDoge1xuICAgICAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgICAgICBwYXRobmFtZTogaW5pdGlhbERhdGEucGFnZSxcbiAgICAgICAgICAgICAgICBxdWVyeTogaW5pdGlhbERhdGEucXVlcnksXG4gICAgICAgICAgICAgICAgYXNQYXRoLFxuICAgICAgICAgICAgICAgIEFwcFRyZWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgoKF9yZW5kZXJFcnJvclByb3BzX3Byb3BzID0gcmVuZGVyRXJyb3JQcm9wcy5wcm9wcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9yZW5kZXJFcnJvclByb3BzX3Byb3BzLmVycikgPyByZW5kZXJFcnJvclByb3BzLnByb3BzIDogKDAsIF91dGlscy5sb2FkR2V0SW5pdGlhbFByb3BzKShBcHAsIGFwcEN0eCkpLnRoZW4oKGluaXRQcm9wcyk9Pi8vIFRPRE86IEZpeCBkaXNhYmxlZCBlc2xpbnQgcnVsZVxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICAgICAgZG9SZW5kZXIoe1xuICAgICAgICAgICAgICAgIC4uLnJlbmRlckVycm9yUHJvcHMsXG4gICAgICAgICAgICAgICAgZXJyLFxuICAgICAgICAgICAgICAgIENvbXBvbmVudDogRXJyb3JDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgc3R5bGVTaGVldHMsXG4gICAgICAgICAgICAgICAgcHJvcHM6IGluaXRQcm9wc1xuICAgICAgICAgICAgfSkpO1xuICAgIH0pO1xufVxuLy8gRHVtbXkgY29tcG9uZW50IHRoYXQgd2UgcmVuZGVyIGFzIGEgY2hpbGQgb2YgUm9vdCBzbyB0aGF0IHdlIGNhblxuLy8gdG9nZ2xlIHRoZSBjb3JyZWN0IHN0eWxlcyBiZWZvcmUgdGhlIHBhZ2UgaXMgcmVuZGVyZWQuXG5mdW5jdGlvbiBIZWFkKHBhcmFtKSB7XG4gICAgbGV0IHsgY2FsbGJhY2sgIH0gPSBwYXJhbTtcbiAgICAvLyBXZSB1c2UgYHVzZUxheW91dEVmZmVjdGAgdG8gZ3VhcmFudGVlIHRoZSBjYWxsYmFjayBpcyBleGVjdXRlZFxuICAgIC8vIGFzIHNvb24gYXMgUmVhY3QgZmx1c2hlcyB0aGUgdXBkYXRlLlxuICAgIF9yZWFjdC5kZWZhdWx0LnVzZUxheW91dEVmZmVjdCgoKT0+Y2FsbGJhY2soKSwgW1xuICAgICAgICBjYWxsYmFja1xuICAgIF0pO1xuICAgIHJldHVybiBudWxsO1xufVxubGV0IHJlYWN0Um9vdCA9IG51bGw7XG4vLyBPbiBpbml0aWFsIHJlbmRlciBhIGh5ZHJhdGUgc2hvdWxkIGFsd2F5cyBoYXBwZW5cbmxldCBzaG91bGRIeWRyYXRlID0gdHJ1ZTtcbmZ1bmN0aW9uIGNsZWFyTWFya3MoKSB7XG4gICAgW1xuICAgICAgICBcImJlZm9yZVJlbmRlclwiLFxuICAgICAgICBcImFmdGVySHlkcmF0ZVwiLFxuICAgICAgICBcImFmdGVyUmVuZGVyXCIsXG4gICAgICAgIFwicm91dGVDaGFuZ2VcIlxuICAgIF0uZm9yRWFjaCgobWFyayk9PnBlcmZvcm1hbmNlLmNsZWFyTWFya3MobWFyaykpO1xufVxuZnVuY3Rpb24gbWFya0h5ZHJhdGVDb21wbGV0ZSgpIHtcbiAgICBpZiAoIV91dGlscy5TVCkgcmV0dXJuO1xuICAgIHBlcmZvcm1hbmNlLm1hcmsoXCJhZnRlckh5ZHJhdGVcIikgLy8gbWFyayBlbmQgb2YgaHlkcmF0aW9uXG4gICAgO1xuICAgIHBlcmZvcm1hbmNlLm1lYXN1cmUoXCJOZXh0LmpzLWJlZm9yZS1oeWRyYXRpb25cIiwgXCJuYXZpZ2F0aW9uU3RhcnRcIiwgXCJiZWZvcmVSZW5kZXJcIik7XG4gICAgcGVyZm9ybWFuY2UubWVhc3VyZShcIk5leHQuanMtaHlkcmF0aW9uXCIsIFwiYmVmb3JlUmVuZGVyXCIsIFwiYWZ0ZXJIeWRyYXRlXCIpO1xuICAgIGlmIChvblBlcmZFbnRyeSkge1xuICAgICAgICBwZXJmb3JtYW5jZS5nZXRFbnRyaWVzQnlOYW1lKFwiTmV4dC5qcy1oeWRyYXRpb25cIikuZm9yRWFjaChvblBlcmZFbnRyeSk7XG4gICAgfVxuICAgIGNsZWFyTWFya3MoKTtcbn1cbmZ1bmN0aW9uIG1hcmtSZW5kZXJDb21wbGV0ZSgpIHtcbiAgICBpZiAoIV91dGlscy5TVCkgcmV0dXJuO1xuICAgIHBlcmZvcm1hbmNlLm1hcmsoXCJhZnRlclJlbmRlclwiKSAvLyBtYXJrIGVuZCBvZiByZW5kZXJcbiAgICA7XG4gICAgY29uc3QgbmF2U3RhcnRFbnRyaWVzID0gcGVyZm9ybWFuY2UuZ2V0RW50cmllc0J5TmFtZShcInJvdXRlQ2hhbmdlXCIsIFwibWFya1wiKTtcbiAgICBpZiAoIW5hdlN0YXJ0RW50cmllcy5sZW5ndGgpIHJldHVybjtcbiAgICBwZXJmb3JtYW5jZS5tZWFzdXJlKFwiTmV4dC5qcy1yb3V0ZS1jaGFuZ2UtdG8tcmVuZGVyXCIsIG5hdlN0YXJ0RW50cmllc1swXS5uYW1lLCBcImJlZm9yZVJlbmRlclwiKTtcbiAgICBwZXJmb3JtYW5jZS5tZWFzdXJlKFwiTmV4dC5qcy1yZW5kZXJcIiwgXCJiZWZvcmVSZW5kZXJcIiwgXCJhZnRlclJlbmRlclwiKTtcbiAgICBpZiAob25QZXJmRW50cnkpIHtcbiAgICAgICAgcGVyZm9ybWFuY2UuZ2V0RW50cmllc0J5TmFtZShcIk5leHQuanMtcmVuZGVyXCIpLmZvckVhY2gob25QZXJmRW50cnkpO1xuICAgICAgICBwZXJmb3JtYW5jZS5nZXRFbnRyaWVzQnlOYW1lKFwiTmV4dC5qcy1yb3V0ZS1jaGFuZ2UtdG8tcmVuZGVyXCIpLmZvckVhY2gob25QZXJmRW50cnkpO1xuICAgIH1cbiAgICBjbGVhck1hcmtzKCk7XG4gICAgW1xuICAgICAgICBcIk5leHQuanMtcm91dGUtY2hhbmdlLXRvLXJlbmRlclwiLFxuICAgICAgICBcIk5leHQuanMtcmVuZGVyXCJcbiAgICBdLmZvckVhY2goKG1lYXN1cmUpPT5wZXJmb3JtYW5jZS5jbGVhck1lYXN1cmVzKG1lYXN1cmUpKTtcbn1cbmZ1bmN0aW9uIHJlbmRlclJlYWN0RWxlbWVudChkb21FbCwgZm4pIHtcbiAgICAvLyBtYXJrIHN0YXJ0IG9mIGh5ZHJhdGUvcmVuZGVyXG4gICAgaWYgKF91dGlscy5TVCkge1xuICAgICAgICBwZXJmb3JtYW5jZS5tYXJrKFwiYmVmb3JlUmVuZGVyXCIpO1xuICAgIH1cbiAgICBjb25zdCByZWFjdEVsID0gZm4oc2hvdWxkSHlkcmF0ZSA/IG1hcmtIeWRyYXRlQ29tcGxldGUgOiBtYXJrUmVuZGVyQ29tcGxldGUpO1xuICAgIGlmICghcmVhY3RSb290KSB7XG4gICAgICAgIC8vIFVubGlrZSB3aXRoIGNyZWF0ZVJvb3QsIHlvdSBkb24ndCBuZWVkIGEgc2VwYXJhdGUgcm9vdC5yZW5kZXIoKSBjYWxsIGhlcmVcbiAgICAgICAgcmVhY3RSb290ID0gX2NsaWVudC5kZWZhdWx0Lmh5ZHJhdGVSb290KGRvbUVsLCByZWFjdEVsLCB7XG4gICAgICAgICAgICBvblJlY292ZXJhYmxlRXJyb3I6IF9vbnJlY292ZXJhYmxlZXJyb3IuZGVmYXVsdFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gVE9ETzogUmVtb3ZlIHNob3VsZEh5ZHJhdGUgdmFyaWFibGUgd2hlbiBSZWFjdCAxOCBpcyBzdGFibGUgYXMgaXQgY2FuIGRlcGVuZCBvbiBgcmVhY3RSb290YCBleGlzdGluZ1xuICAgICAgICBzaG91bGRIeWRyYXRlID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgc3RhcnRUcmFuc2l0aW9uID0gX3JlYWN0LmRlZmF1bHQuc3RhcnRUcmFuc2l0aW9uO1xuICAgICAgICBzdGFydFRyYW5zaXRpb24oKCk9PntcbiAgICAgICAgICAgIHJlYWN0Um9vdC5yZW5kZXIocmVhY3RFbCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIFJvb3QocGFyYW0pIHtcbiAgICBsZXQgeyBjYWxsYmFja3MgLCBjaGlsZHJlbiAgfSA9IHBhcmFtO1xuICAgIC8vIFdlIHVzZSBgdXNlTGF5b3V0RWZmZWN0YCB0byBndWFyYW50ZWUgdGhlIGNhbGxiYWNrcyBhcmUgZXhlY3V0ZWRcbiAgICAvLyBhcyBzb29uIGFzIFJlYWN0IGZsdXNoZXMgdGhlIHVwZGF0ZVxuICAgIF9yZWFjdC5kZWZhdWx0LnVzZUxheW91dEVmZmVjdCgoKT0+Y2FsbGJhY2tzLmZvckVhY2goKGNhbGxiYWNrKT0+Y2FsbGJhY2soKSksIFtcbiAgICAgICAgY2FsbGJhY2tzXG4gICAgXSk7XG4gICAgLy8gV2Ugc2hvdWxkIGFzayB0byBtZWFzdXJlIHRoZSBXZWIgVml0YWxzIGFmdGVyIHJlbmRlcmluZyBjb21wbGV0ZXMgc28gd2VcbiAgICAvLyBkb24ndCBjYXVzZSBhbnkgaHlkcmF0aW9uIGRlbGF5OlxuICAgIF9yZWFjdC5kZWZhdWx0LnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICAoMCwgX3BlcmZvcm1hbmNlcmVsYXllci5kZWZhdWx0KShvblBlcmZFbnRyeSk7XG4gICAgfSwgW10pO1xuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfVEVTVF9NT0RFKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgICAgICBfcmVhY3QuZGVmYXVsdC51c2VFZmZlY3QoKCk9PntcbiAgICAgICAgICAgIHdpbmRvdy5fX05FWFRfSFlEUkFURUQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHdpbmRvdy5fX05FWFRfSFlEUkFURURfQ0IpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuX19ORVhUX0hZRFJBVEVEX0NCKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFtdKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xufVxuZnVuY3Rpb24gZG9SZW5kZXIoaW5wdXQpIHtcbiAgICBsZXQgeyBBcHAgLCBDb21wb25lbnQgLCBwcm9wcyAsIGVyciAgfSA9IGlucHV0O1xuICAgIGxldCBzdHlsZVNoZWV0cyA9IFwiaW5pdGlhbFwiIGluIGlucHV0ID8gdW5kZWZpbmVkIDogaW5wdXQuc3R5bGVTaGVldHM7XG4gICAgQ29tcG9uZW50ID0gQ29tcG9uZW50IHx8IGxhc3RBcHBQcm9wcy5Db21wb25lbnQ7XG4gICAgcHJvcHMgPSBwcm9wcyB8fCBsYXN0QXBwUHJvcHMucHJvcHM7XG4gICAgY29uc3QgYXBwUHJvcHMgPSB7XG4gICAgICAgIC4uLnByb3BzLFxuICAgICAgICBDb21wb25lbnQsXG4gICAgICAgIGVycixcbiAgICAgICAgcm91dGVyXG4gICAgfTtcbiAgICAvLyBsYXN0QXBwUHJvcHMgaGFzIHRvIGJlIHNldCBiZWZvcmUgUmVhY3REb20ucmVuZGVyIHRvIGFjY291bnQgZm9yIFJlYWN0RG9tIHRocm93aW5nIGFuIGVycm9yLlxuICAgIGxhc3RBcHBQcm9wcyA9IGFwcFByb3BzO1xuICAgIGxldCBjYW5jZWxlZCA9IGZhbHNlO1xuICAgIGxldCByZXNvbHZlUHJvbWlzZTtcbiAgICBjb25zdCByZW5kZXJQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCk9PntcbiAgICAgICAgaWYgKGxhc3RSZW5kZXJSZWplY3QpIHtcbiAgICAgICAgICAgIGxhc3RSZW5kZXJSZWplY3QoKTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlUHJvbWlzZSA9ICgpPT57XG4gICAgICAgICAgICBsYXN0UmVuZGVyUmVqZWN0ID0gbnVsbDtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgbGFzdFJlbmRlclJlamVjdCA9ICgpPT57XG4gICAgICAgICAgICBjYW5jZWxlZCA9IHRydWU7XG4gICAgICAgICAgICBsYXN0UmVuZGVyUmVqZWN0ID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKFwiQ2FuY2VsIHJlbmRlcmluZyByb3V0ZVwiKTtcbiAgICAgICAgICAgIGVycm9yLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICB9O1xuICAgIH0pO1xuICAgIC8vIFRoaXMgZnVuY3Rpb24gaGFzIGEgcmV0dXJuIHR5cGUgdG8gZW5zdXJlIGl0IGRvZXNuJ3Qgc3RhcnQgcmV0dXJuaW5nIGFcbiAgICAvLyBQcm9taXNlLiBJdCBzaG91bGQgcmVtYWluIHN5bmNocm9ub3VzLlxuICAgIGZ1bmN0aW9uIG9uU3RhcnQoKSB7XG4gICAgICAgIGlmICghc3R5bGVTaGVldHMgfHwgLy8gV2UgdXNlIGBzdHlsZS1sb2FkZXJgIGluIGRldmVsb3BtZW50LCBzbyB3ZSBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nXG4gICAgICAgIC8vIHVubGVzcyB3ZSdyZSBpbiBwcm9kdWN0aW9uOlxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJyZW50U3R5bGVUYWdzID0gbG9vc2VUb0FycmF5KGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJzdHlsZVtkYXRhLW4taHJlZl1cIikpO1xuICAgICAgICBjb25zdCBjdXJyZW50SHJlZnMgPSBuZXcgU2V0KGN1cnJlbnRTdHlsZVRhZ3MubWFwKCh0YWcpPT50YWcuZ2V0QXR0cmlidXRlKFwiZGF0YS1uLWhyZWZcIikpKTtcbiAgICAgICAgY29uc3Qgbm9zY3JpcHQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwibm9zY3JpcHRbZGF0YS1uLWNzc11cIik7XG4gICAgICAgIGNvbnN0IG5vbmNlID0gbm9zY3JpcHQgPT0gbnVsbCA/IHZvaWQgMCA6IG5vc2NyaXB0LmdldEF0dHJpYnV0ZShcImRhdGEtbi1jc3NcIik7XG4gICAgICAgIHN0eWxlU2hlZXRzLmZvckVhY2goKHBhcmFtKT0+e1xuICAgICAgICAgICAgbGV0IHsgaHJlZiAsIHRleHQgIH0gPSBwYXJhbTtcbiAgICAgICAgICAgIGlmICghY3VycmVudEhyZWZzLmhhcyhocmVmKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0eWxlVGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgICAgICAgICAgICAgIHN0eWxlVGFnLnNldEF0dHJpYnV0ZShcImRhdGEtbi1ocmVmXCIsIGhyZWYpO1xuICAgICAgICAgICAgICAgIHN0eWxlVGFnLnNldEF0dHJpYnV0ZShcIm1lZGlhXCIsIFwieFwiKTtcbiAgICAgICAgICAgICAgICBpZiAobm9uY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVUYWcuc2V0QXR0cmlidXRlKFwibm9uY2VcIiwgbm9uY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHN0eWxlVGFnKTtcbiAgICAgICAgICAgICAgICBzdHlsZVRhZy5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25IZWFkQ29tbWl0KCkge1xuICAgICAgICBpZiAoLy8gV2UgdXNlIGBzdHlsZS1sb2FkZXJgIGluIGRldmVsb3BtZW50LCBzbyB3ZSBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nXG4gICAgICAgIC8vIHVubGVzcyB3ZSdyZSBpbiBwcm9kdWN0aW9uOlxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgJiYgLy8gV2UgY2FuIHNraXAgdGhpcyBkdXJpbmcgaHlkcmF0aW9uLiBSdW5uaW5nIGl0IHdvbnQgY2F1c2UgYW55IGhhcm0sIGJ1dFxuICAgICAgICAvLyB3ZSBtYXkgYXMgd2VsbCBzYXZlIHRoZSBDUFUgY3ljbGVzOlxuICAgICAgICBzdHlsZVNoZWV0cyAmJiAvLyBFbnN1cmUgdGhpcyByZW5kZXIgd2FzIG5vdCBjYW5jZWxlZFxuICAgICAgICAhY2FuY2VsZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlc2lyZWRIcmVmcyA9IG5ldyBTZXQoc3R5bGVTaGVldHMubWFwKChzKT0+cy5ocmVmKSk7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50U3R5bGVUYWdzID0gbG9vc2VUb0FycmF5KGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJzdHlsZVtkYXRhLW4taHJlZl1cIikpO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudEhyZWZzID0gY3VycmVudFN0eWxlVGFncy5tYXAoKHRhZyk9PnRhZy5nZXRBdHRyaWJ1dGUoXCJkYXRhLW4taHJlZlwiKSk7XG4gICAgICAgICAgICAvLyBUb2dnbGUgYDxzdHlsZT5gIHRhZ3Mgb24gb3Igb2ZmIGRlcGVuZGluZyBvbiBpZiB0aGV5J3JlIG5lZWRlZDpcbiAgICAgICAgICAgIGZvcihsZXQgaWR4ID0gMDsgaWR4IDwgY3VycmVudEhyZWZzLmxlbmd0aDsgKytpZHgpe1xuICAgICAgICAgICAgICAgIGlmIChkZXNpcmVkSHJlZnMuaGFzKGN1cnJlbnRIcmVmc1tpZHhdKSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U3R5bGVUYWdzW2lkeF0ucmVtb3ZlQXR0cmlidXRlKFwibWVkaWFcIik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFN0eWxlVGFnc1tpZHhdLnNldEF0dHJpYnV0ZShcIm1lZGlhXCIsIFwieFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZW9yZGVyIHN0eWxlcyBpbnRvIGludGVuZGVkIG9yZGVyOlxuICAgICAgICAgICAgbGV0IHJlZmVyZW5jZU5vZGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwibm9zY3JpcHRbZGF0YS1uLWNzc11cIik7XG4gICAgICAgICAgICBpZiAoLy8gVGhpcyBzaG91bGQgYmUgYW4gaW52YXJpYW50OlxuICAgICAgICAgICAgcmVmZXJlbmNlTm9kZSkge1xuICAgICAgICAgICAgICAgIHN0eWxlU2hlZXRzLmZvckVhY2goKHBhcmFtKT0+e1xuICAgICAgICAgICAgICAgICAgICBsZXQgeyBocmVmICB9ID0gcGFyYW07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldFRhZyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3N0eWxlW2RhdGEtbi1ocmVmPVwiJyArIGhyZWYgKyAnXCJdJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICgvLyBUaGlzIHNob3VsZCBiZSBhbiBpbnZhcmlhbnQ6XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFRhZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlTm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0YXJnZXRUYWcsIHJlZmVyZW5jZU5vZGUubmV4dFNpYmxpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlTm9kZSA9IHRhcmdldFRhZztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmluYWxseSwgY2xlYW4gdXAgc2VydmVyIHJlbmRlcmVkIHN0eWxlc2hlZXRzOlxuICAgICAgICAgICAgbG9vc2VUb0FycmF5KGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJsaW5rW2RhdGEtbi1wXVwiKSkuZm9yRWFjaCgoZWwpPT57XG4gICAgICAgICAgICAgICAgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5wdXQuc2Nyb2xsKSB7XG4gICAgICAgICAgICBjb25zdCB7IHggLCB5ICB9ID0gaW5wdXQuc2Nyb2xsO1xuICAgICAgICAgICAgKDAsIF9oYW5kbGVzbW9vdGhzY3JvbGwuaGFuZGxlU21vb3RoU2Nyb2xsKSgoKT0+e1xuICAgICAgICAgICAgICAgIHdpbmRvdy5zY3JvbGxUbyh4LCB5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uUm9vdENvbW1pdCgpIHtcbiAgICAgICAgcmVzb2x2ZVByb21pc2UoKTtcbiAgICB9XG4gICAgb25TdGFydCgpO1xuICAgIGNvbnN0IGVsZW0gPSAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JlYWN0LmRlZmF1bHQuRnJhZ21lbnQsIG51bGwsIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChIZWFkLCB7XG4gICAgICAgIGNhbGxiYWNrOiBvbkhlYWRDb21taXRcbiAgICB9KSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KEFwcENvbnRhaW5lciwgbnVsbCwgcmVuZGVyQXBwKEFwcCwgYXBwUHJvcHMpLCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3BvcnRhbC5Qb3J0YWwsIHtcbiAgICAgICAgdHlwZTogXCJuZXh0LXJvdXRlLWFubm91bmNlclwiXG4gICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9yb3V0ZWFubm91bmNlci5Sb3V0ZUFubm91bmNlciwgbnVsbCkpKSk7XG4gICAgLy8gV2UgY2F0Y2ggcnVudGltZSBlcnJvcnMgdXNpbmcgY29tcG9uZW50RGlkQ2F0Y2ggd2hpY2ggd2lsbCB0cmlnZ2VyIHJlbmRlckVycm9yXG4gICAgcmVuZGVyUmVhY3RFbGVtZW50KGFwcEVsZW1lbnQsIChjYWxsYmFjayk9Pi8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChSb290LCB7XG4gICAgICAgICAgICBjYWxsYmFja3M6IFtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgICAgICAgICBvblJvb3RDb21taXRcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSwgcHJvY2Vzcy5lbnYuX19ORVhUX1NUUklDVF9NT0RFID8gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9yZWFjdC5kZWZhdWx0LlN0cmljdE1vZGUsIG51bGwsIGVsZW0pIDogZWxlbSkpO1xuICAgIHJldHVybiByZW5kZXJQcm9taXNlO1xufVxuYXN5bmMgZnVuY3Rpb24gcmVuZGVyKHJlbmRlcmluZ1Byb3BzKSB7XG4gICAgaWYgKHJlbmRlcmluZ1Byb3BzLmVycikge1xuICAgICAgICBhd2FpdCByZW5kZXJFcnJvcihyZW5kZXJpbmdQcm9wcyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgZG9SZW5kZXIocmVuZGVyaW5nUHJvcHMpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zdCByZW5kZXJFcnIgPSAoMCwgX2lzZXJyb3IuZ2V0UHJvcGVyRXJyb3IpKGVycik7XG4gICAgICAgIC8vIGJ1YmJsZSB1cCBjYW5jZWxhdGlvbiBlcnJvcnNcbiAgICAgICAgaWYgKHJlbmRlckVyci5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIHRocm93IHJlbmRlckVycjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIikge1xuICAgICAgICAgICAgLy8gRW5zdXJlIHRoaXMgZXJyb3IgaXMgZGlzcGxheWVkIGluIHRoZSBvdmVybGF5IGluIGRldmVsb3BtZW50XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICAgICAgdGhyb3cgcmVuZGVyRXJyO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgcmVuZGVyRXJyb3Ioe1xuICAgICAgICAgICAgLi4ucmVuZGVyaW5nUHJvcHMsXG4gICAgICAgICAgICBlcnI6IHJlbmRlckVyclxuICAgICAgICB9KTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBoeWRyYXRlKG9wdHMpIHtcbiAgICBsZXQgaW5pdGlhbEVyciA9IGluaXRpYWxEYXRhLmVycjtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBhcHBFbnRyeXBvaW50ID0gYXdhaXQgcGFnZUxvYWRlci5yb3V0ZUxvYWRlci53aGVuRW50cnlwb2ludChcIi9fYXBwXCIpO1xuICAgICAgICBpZiAoXCJlcnJvclwiIGluIGFwcEVudHJ5cG9pbnQpIHtcbiAgICAgICAgICAgIHRocm93IGFwcEVudHJ5cG9pbnQuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBjb21wb25lbnQ6IGFwcCAsIGV4cG9ydHM6IG1vZCAgfSA9IGFwcEVudHJ5cG9pbnQ7XG4gICAgICAgIENhY2hlZEFwcCA9IGFwcDtcbiAgICAgICAgaWYgKG1vZCAmJiBtb2QucmVwb3J0V2ViVml0YWxzKSB7XG4gICAgICAgICAgICBvblBlcmZFbnRyeSA9IChwYXJhbSk9PntcbiAgICAgICAgICAgICAgICBsZXQgeyBpZCAsIG5hbWUgLCBzdGFydFRpbWUgLCB2YWx1ZSAsIGR1cmF0aW9uICwgZW50cnlUeXBlICwgZW50cmllcyAsIGF0dHJpYnV0aW9uICB9ID0gcGFyYW07XG4gICAgICAgICAgICAgICAgLy8gQ29tYmluZXMgdGltZXN0YW1wIHdpdGggcmFuZG9tIG51bWJlciBmb3IgdW5pcXVlIElEXG4gICAgICAgICAgICAgICAgY29uc3QgdW5pcXVlSUQgPSBEYXRlLm5vdygpICsgXCItXCIgKyAoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKDllMTIgLSAxKSkgKyAxZTEyKTtcbiAgICAgICAgICAgICAgICBsZXQgcGVyZlN0YXJ0RW50cnk7XG4gICAgICAgICAgICAgICAgaWYgKGVudHJpZXMgJiYgZW50cmllcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcGVyZlN0YXJ0RW50cnkgPSBlbnRyaWVzWzBdLnN0YXJ0VGltZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgd2ViVml0YWxzID0ge1xuICAgICAgICAgICAgICAgICAgICBpZDogaWQgfHwgdW5pcXVlSUQsXG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0VGltZTogc3RhcnRUaW1lIHx8IHBlcmZTdGFydEVudHJ5LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUgPT0gbnVsbCA/IGR1cmF0aW9uIDogdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiBlbnRyeVR5cGUgPT09IFwibWFya1wiIHx8IGVudHJ5VHlwZSA9PT0gXCJtZWFzdXJlXCIgPyBcImN1c3RvbVwiIDogXCJ3ZWItdml0YWxcIlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKGF0dHJpYnV0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHdlYlZpdGFscy5hdHRyaWJ1dGlvbiA9IGF0dHJpYnV0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtb2QucmVwb3J0V2ViVml0YWxzKHdlYlZpdGFscyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhZ2VFbnRyeXBvaW50ID0gLy8gVGhlIGRldiBzZXJ2ZXIgZmFpbHMgdG8gc2VydmUgc2NyaXB0IGFzc2V0cyB3aGVuIHRoZXJlJ3MgYSBoeWRyYXRpb25cbiAgICAgICAgLy8gZXJyb3IsIHNvIHdlIG5lZWQgdG8gc2tpcCB3YWl0aW5nIGZvciB0aGUgZW50cnlwb2ludC5cbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIiAmJiBpbml0aWFsRGF0YS5lcnIgPyB7XG4gICAgICAgICAgICBlcnJvcjogaW5pdGlhbERhdGEuZXJyXG4gICAgICAgIH0gOiBhd2FpdCBwYWdlTG9hZGVyLnJvdXRlTG9hZGVyLndoZW5FbnRyeXBvaW50KGluaXRpYWxEYXRhLnBhZ2UpO1xuICAgICAgICBpZiAoXCJlcnJvclwiIGluIHBhZ2VFbnRyeXBvaW50KSB7XG4gICAgICAgICAgICB0aHJvdyBwYWdlRW50cnlwb2ludC5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBDYWNoZWRDb21wb25lbnQgPSBwYWdlRW50cnlwb2ludC5jb21wb25lbnQ7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaXNWYWxpZEVsZW1lbnRUeXBlICB9ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9yZWFjdC1pc1wiKTtcbiAgICAgICAgICAgIGlmICghaXNWYWxpZEVsZW1lbnRUeXBlKENhY2hlZENvbXBvbmVudCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBkZWZhdWx0IGV4cG9ydCBpcyBub3QgYSBSZWFjdCBDb21wb25lbnQgaW4gcGFnZTogXCInICsgaW5pdGlhbERhdGEucGFnZSArICdcIicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8gVGhpcyBjYXRjaGVzIGVycm9ycyBsaWtlIHRocm93aW5nIGluIHRoZSB0b3AgbGV2ZWwgb2YgYSBtb2R1bGVcbiAgICAgICAgaW5pdGlhbEVyciA9ICgwLCBfaXNlcnJvci5nZXRQcm9wZXJFcnJvcikoZXJyb3IpO1xuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIikge1xuICAgICAgICBjb25zdCB7IGdldFNlcnZlckVycm9yICB9ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9kaXN0L2NsaWVudFwiKTtcbiAgICAgICAgLy8gU2VydmVyLXNpZGUgcnVudGltZSBlcnJvcnMgbmVlZCB0byBiZSByZS10aHJvd24gb24gdGhlIGNsaWVudC1zaWRlIHNvXG4gICAgICAgIC8vIHRoYXQgdGhlIG92ZXJsYXkgaXMgcmVuZGVyZWQuXG4gICAgICAgIGlmIChpbml0aWFsRXJyKSB7XG4gICAgICAgICAgICBpZiAoaW5pdGlhbEVyciA9PT0gaW5pdGlhbERhdGEuZXJyKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKT0+e1xuICAgICAgICAgICAgICAgICAgICBsZXQgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHZW5lcmF0ZSBhIG5ldyBlcnJvciBvYmplY3QuIFdlIGB0aHJvd2AgaXQgYmVjYXVzZSBzb21lIGJyb3dzZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3aWxsIHNldCB0aGUgYHN0YWNrYCB3aGVuIHRocm93biwgYW5kIHdlIHdhbnQgdG8gZW5zdXJlIG91cnMgaXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdCBvdmVycmlkZGVuIHdoZW4gd2UgcmUtdGhyb3cgaXQgYmVsb3cuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoaW5pdGlhbEVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLm5hbWUgPSBpbml0aWFsRXJyLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLnN0YWNrID0gaW5pdGlhbEVyci5zdGFjaztcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZ2V0U2VydmVyRXJyb3IoZXJyb3IsIGluaXRpYWxFcnIuc291cmNlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKT0+e1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBpbml0aWFsRXJyO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh3aW5kb3cuX19ORVhUX1BSRUxPQURSRUFEWSkge1xuICAgICAgICBhd2FpdCB3aW5kb3cuX19ORVhUX1BSRUxPQURSRUFEWShpbml0aWFsRGF0YS5keW5hbWljSWRzKTtcbiAgICB9XG4gICAgcm91dGVyID0gKDAsIF9yb3V0ZXIuY3JlYXRlUm91dGVyKShpbml0aWFsRGF0YS5wYWdlLCBpbml0aWFsRGF0YS5xdWVyeSwgYXNQYXRoLCB7XG4gICAgICAgIGluaXRpYWxQcm9wczogaW5pdGlhbERhdGEucHJvcHMsXG4gICAgICAgIHBhZ2VMb2FkZXIsXG4gICAgICAgIEFwcDogQ2FjaGVkQXBwLFxuICAgICAgICBDb21wb25lbnQ6IENhY2hlZENvbXBvbmVudCxcbiAgICAgICAgd3JhcEFwcCxcbiAgICAgICAgZXJyOiBpbml0aWFsRXJyLFxuICAgICAgICBpc0ZhbGxiYWNrOiBCb29sZWFuKGluaXRpYWxEYXRhLmlzRmFsbGJhY2spLFxuICAgICAgICBzdWJzY3JpcHRpb246IChpbmZvLCBBcHAsIHNjcm9sbCk9PnJlbmRlcihPYmplY3QuYXNzaWduKHt9LCBpbmZvLCB7XG4gICAgICAgICAgICAgICAgQXBwLFxuICAgICAgICAgICAgICAgIHNjcm9sbFxuICAgICAgICAgICAgfSkpLFxuICAgICAgICBsb2NhbGU6IGluaXRpYWxEYXRhLmxvY2FsZSxcbiAgICAgICAgbG9jYWxlczogaW5pdGlhbERhdGEubG9jYWxlcyxcbiAgICAgICAgZGVmYXVsdExvY2FsZSxcbiAgICAgICAgZG9tYWluTG9jYWxlczogaW5pdGlhbERhdGEuZG9tYWluTG9jYWxlcyxcbiAgICAgICAgaXNQcmV2aWV3OiBpbml0aWFsRGF0YS5pc1ByZXZpZXdcbiAgICB9KTtcbiAgICBpbml0aWFsTWF0Y2hlc01pZGRsZXdhcmUgPSBhd2FpdCByb3V0ZXIuX2luaXRpYWxNYXRjaGVzTWlkZGxld2FyZVByb21pc2U7XG4gICAgY29uc3QgcmVuZGVyQ3R4ID0ge1xuICAgICAgICBBcHA6IENhY2hlZEFwcCxcbiAgICAgICAgaW5pdGlhbDogdHJ1ZSxcbiAgICAgICAgQ29tcG9uZW50OiBDYWNoZWRDb21wb25lbnQsXG4gICAgICAgIHByb3BzOiBpbml0aWFsRGF0YS5wcm9wcyxcbiAgICAgICAgZXJyOiBpbml0aWFsRXJyXG4gICAgfTtcbiAgICBpZiAob3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5iZWZvcmVSZW5kZXIpIHtcbiAgICAgICAgYXdhaXQgb3B0cy5iZWZvcmVSZW5kZXIoKTtcbiAgICB9XG4gICAgcmVuZGVyKHJlbmRlckN0eCk7XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm1vZHVsZSIsInZlcnNpb24iLCJyb3V0ZXIiLCJlbWl0dGVyIiwiaW5pdGlhbGl6ZSIsImh5ZHJhdGUiLCJfZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImVudW1lcmFibGUiLCJnZXQiLCJfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQiLCJyZXF1aXJlIiwiX3JlYWN0IiwiXyIsIl9jbGllbnQiLCJfaGVhZG1hbmFnZXJjb250ZXh0IiwiX21pdHQiLCJfcm91dGVyY29udGV4dCIsIl9oYW5kbGVzbW9vdGhzY3JvbGwiLCJfaXNkeW5hbWljIiwiX3F1ZXJ5c3RyaW5nIiwiX3J1bnRpbWVjb25maWciLCJfdXRpbHMiLCJfcG9ydGFsIiwiX2hlYWRtYW5hZ2VyIiwiX3BhZ2Vsb2FkZXIiLCJfcGVyZm9ybWFuY2VyZWxheWVyIiwiX3JvdXRlYW5ub3VuY2VyIiwiX3JvdXRlciIsIl9pc2Vycm9yIiwiX2ltYWdlY29uZmlnY29udGV4dCIsIl9yZW1vdmViYXNlcGF0aCIsIl9oYXNiYXNlcGF0aCIsIl9hcHByb3V0ZXJjb250ZXh0IiwiX2FkYXB0ZXJzIiwiX2hvb2tzY2xpZW50Y29udGV4dCIsIl9vbnJlY292ZXJhYmxlZXJyb3IiLCJhZGRDaHVua1N1ZmZpeCIsImdldE9yaWdpbmFsQ2h1bmsiLCJjaHVua0lkIiwicHJvY2VzcyIsImVudiIsIk5FWFRfREVQTE9ZTUVOVF9JRCIsImdldENodW5rU2NyaXB0RmlsZW5hbWUiLCJfX3dlYnBhY2tfcmVxdWlyZV9fIiwidSIsImdldENodW5rQ3NzRmlsZW5hbWUiLCJrIiwiZ2V0TWluaUNzc0ZpbGVuYW1lIiwibWluaUNzc0YiLCJkZWZhdWx0IiwibG9vc2VUb0FycmF5IiwiaW5wdXQiLCJzbGljZSIsImNhbGwiLCJpbml0aWFsRGF0YSIsImRlZmF1bHRMb2NhbGUiLCJ1bmRlZmluZWQiLCJhc1BhdGgiLCJwYWdlTG9hZGVyIiwiYXBwRWxlbWVudCIsImhlYWRNYW5hZ2VyIiwiaW5pdGlhbE1hdGNoZXNNaWRkbGV3YXJlIiwibGFzdEFwcFByb3BzIiwibGFzdFJlbmRlclJlamVjdCIsIndlYnBhY2tITVIiLCJDYWNoZWRBcHAiLCJvblBlcmZFbnRyeSIsIkNhY2hlZENvbXBvbmVudCIsInNlbGYiLCJfX25leHRfcmVxdWlyZV9fIiwiQ29udGFpbmVyIiwiQ29tcG9uZW50IiwiY29tcG9uZW50RGlkQ2F0Y2giLCJjb21wb25lbnRFcnIiLCJpbmZvIiwicHJvcHMiLCJmbiIsImNvbXBvbmVudERpZE1vdW50Iiwic2Nyb2xsVG9IYXNoIiwiaXNTc3IiLCJpc0ZhbGxiYWNrIiwibmV4dEV4cG9ydCIsImlzRHluYW1pY1JvdXRlIiwicGF0aG5hbWUiLCJsb2NhdGlvbiIsInNlYXJjaCIsIl9fTkVYVF9IQVNfUkVXUklURVMiLCJfX05fU1NHIiwicmVwbGFjZSIsIlN0cmluZyIsImFzc2lnbiIsInVybFF1ZXJ5VG9TZWFyY2hQYXJhbXMiLCJxdWVyeSIsIlVSTFNlYXJjaFBhcmFtcyIsIl9oIiwic2hhbGxvdyIsImNhdGNoIiwiZXJyIiwiY2FuY2VsbGVkIiwiY29tcG9uZW50RGlkVXBkYXRlIiwiaGFzaCIsInN1YnN0cmluZyIsImVsIiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsInNldFRpbWVvdXQiLCJzY3JvbGxJbnRvVmlldyIsInJlbmRlciIsImNoaWxkcmVuIiwiUmVhY3REZXZPdmVybGF5IiwiY3JlYXRlRWxlbWVudCIsIm9wdHMiLCJKU09OIiwicGFyc2UiLCJ0ZXh0Q29udGVudCIsIndpbmRvdyIsIl9fTkVYVF9EQVRBX18iLCJwcmVmaXgiLCJhc3NldFByZWZpeCIsIl9fd2VicGFja19wdWJsaWNfcGF0aF9fIiwic2V0Q29uZmlnIiwic2VydmVyUnVudGltZUNvbmZpZyIsInB1YmxpY1J1bnRpbWVDb25maWciLCJydW50aW1lQ29uZmlnIiwiZ2V0VVJMIiwiaGFzQmFzZVBhdGgiLCJyZW1vdmVCYXNlUGF0aCIsIl9fTkVYVF9JMThOX1NVUFBPUlQiLCJub3JtYWxpemVMb2NhbGVQYXRoIiwiZGV0ZWN0RG9tYWluTG9jYWxlIiwicGFyc2VSZWxhdGl2ZVVybCIsImZvcm1hdFVybCIsImxvY2FsZXMiLCJwYXJzZWRBcyIsImxvY2FsZVBhdGhSZXN1bHQiLCJkZXRlY3RlZExvY2FsZSIsImxvY2FsZSIsImRldGVjdGVkRG9tYWluIiwiX19ORVhUX0kxOE5fRE9NQUlOUyIsImhvc3RuYW1lIiwic2NyaXB0TG9hZGVyIiwiaW5pdFNjcmlwdExvYWRlciIsImJ1aWxkSWQiLCJyZWdpc3RlciIsInBhcmFtIiwiciIsImYiLCJyb3V0ZUxvYWRlciIsIm9uRW50cnlwb2ludCIsIl9fTkVYVF9QIiwibWFwIiwicCIsInB1c2giLCJnZXRJc1NzciIsInJlbmRlckFwcCIsIkFwcCIsImFwcFByb3BzIiwiQXBwQ29udGFpbmVyIiwiYWRhcHRlZEZvckFwcFJvdXRlciIsInVzZU1lbW8iLCJhZGFwdEZvckFwcFJvdXRlckluc3RhbmNlIiwiX3NlbGZfX19ORVhUX0RBVEFfX19hdXRvRXhwb3J0IiwiZXJyb3IiLCJyZW5kZXJFcnJvciIsImNvbnNvbGUiLCJBcHBSb3V0ZXJDb250ZXh0IiwiUHJvdmlkZXIiLCJTZWFyY2hQYXJhbXNDb250ZXh0IiwiYWRhcHRGb3JTZWFyY2hQYXJhbXMiLCJQYXRobmFtZUNvbnRleHRQcm92aWRlckFkYXB0ZXIiLCJpc0F1dG9FeHBvcnQiLCJhdXRvRXhwb3J0IiwiUm91dGVyQ29udGV4dCIsIm1ha2VQdWJsaWNSb3V0ZXJJbnN0YW5jZSIsIkhlYWRNYW5hZ2VyQ29udGV4dCIsIkltYWdlQ29uZmlnQ29udGV4dCIsIl9fTkVYVF9JTUFHRV9PUFRTIiwid3JhcEFwcCIsIndyYXBwZWRBcHBQcm9wcyIsInJlbmRlckVycm9yUHJvcHMiLCJvblVucmVjb3ZlcmFibGVFcnJvciIsImRvUmVuZGVyIiwic3R5bGVTaGVldHMiLCJsb2FkUGFnZSIsInRoZW4iLCJwYWdlIiwiRXJyb3JDb21wb25lbnQiLCJlcnJvck1vZHVsZSIsImFwcE1vZHVsZSIsIm0iLCJfcmVuZGVyRXJyb3JQcm9wc19wcm9wcyIsIkFwcFRyZWUiLCJhcHBDdHgiLCJjdHgiLCJQcm9taXNlIiwicmVzb2x2ZSIsImxvYWRHZXRJbml0aWFsUHJvcHMiLCJpbml0UHJvcHMiLCJIZWFkIiwiY2FsbGJhY2siLCJ1c2VMYXlvdXRFZmZlY3QiLCJyZWFjdFJvb3QiLCJzaG91bGRIeWRyYXRlIiwiY2xlYXJNYXJrcyIsImZvckVhY2giLCJtYXJrIiwicGVyZm9ybWFuY2UiLCJtYXJrSHlkcmF0ZUNvbXBsZXRlIiwiU1QiLCJtZWFzdXJlIiwiZ2V0RW50cmllc0J5TmFtZSIsIm1hcmtSZW5kZXJDb21wbGV0ZSIsIm5hdlN0YXJ0RW50cmllcyIsImxlbmd0aCIsImNsZWFyTWVhc3VyZXMiLCJyZW5kZXJSZWFjdEVsZW1lbnQiLCJkb21FbCIsInJlYWN0RWwiLCJoeWRyYXRlUm9vdCIsIm9uUmVjb3ZlcmFibGVFcnJvciIsInN0YXJ0VHJhbnNpdGlvbiIsIlJvb3QiLCJjYWxsYmFja3MiLCJ1c2VFZmZlY3QiLCJfX05FWFRfVEVTVF9NT0RFIiwiX19ORVhUX0hZRFJBVEVEIiwiX19ORVhUX0hZRFJBVEVEX0NCIiwiY2FuY2VsZWQiLCJyZXNvbHZlUHJvbWlzZSIsInJlbmRlclByb21pc2UiLCJyZWplY3QiLCJFcnJvciIsIm9uU3RhcnQiLCJjdXJyZW50U3R5bGVUYWdzIiwicXVlcnlTZWxlY3RvckFsbCIsImN1cnJlbnRIcmVmcyIsIlNldCIsInRhZyIsImdldEF0dHJpYnV0ZSIsIm5vc2NyaXB0IiwicXVlcnlTZWxlY3RvciIsIm5vbmNlIiwiaHJlZiIsInRleHQiLCJoYXMiLCJzdHlsZVRhZyIsInNldEF0dHJpYnV0ZSIsImhlYWQiLCJhcHBlbmRDaGlsZCIsImNyZWF0ZVRleHROb2RlIiwib25IZWFkQ29tbWl0IiwiZGVzaXJlZEhyZWZzIiwicyIsImlkeCIsInJlbW92ZUF0dHJpYnV0ZSIsInJlZmVyZW5jZU5vZGUiLCJ0YXJnZXRUYWciLCJwYXJlbnROb2RlIiwiaW5zZXJ0QmVmb3JlIiwibmV4dFNpYmxpbmciLCJyZW1vdmVDaGlsZCIsInNjcm9sbCIsIngiLCJ5IiwiaGFuZGxlU21vb3RoU2Nyb2xsIiwic2Nyb2xsVG8iLCJvblJvb3RDb21taXQiLCJlbGVtIiwiRnJhZ21lbnQiLCJQb3J0YWwiLCJ0eXBlIiwiUm91dGVBbm5vdW5jZXIiLCJfX05FWFRfU1RSSUNUX01PREUiLCJTdHJpY3RNb2RlIiwicmVuZGVyaW5nUHJvcHMiLCJyZW5kZXJFcnIiLCJnZXRQcm9wZXJFcnJvciIsImluaXRpYWxFcnIiLCJhcHBFbnRyeXBvaW50Iiwid2hlbkVudHJ5cG9pbnQiLCJjb21wb25lbnQiLCJhcHAiLCJtb2QiLCJyZXBvcnRXZWJWaXRhbHMiLCJpZCIsInN0YXJ0VGltZSIsImR1cmF0aW9uIiwiZW50cnlUeXBlIiwiZW50cmllcyIsImF0dHJpYnV0aW9uIiwidW5pcXVlSUQiLCJEYXRlIiwibm93IiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwicGVyZlN0YXJ0RW50cnkiLCJ3ZWJWaXRhbHMiLCJsYWJlbCIsInBhZ2VFbnRyeXBvaW50IiwiaXNWYWxpZEVsZW1lbnRUeXBlIiwiZ2V0U2VydmVyRXJyb3IiLCJtZXNzYWdlIiwiZSIsInN0YWNrIiwic291cmNlIiwiX19ORVhUX1BSRUxPQURSRUFEWSIsImR5bmFtaWNJZHMiLCJjcmVhdGVSb3V0ZXIiLCJpbml0aWFsUHJvcHMiLCJCb29sZWFuIiwic3Vic2NyaXB0aW9uIiwiZG9tYWluTG9jYWxlcyIsImlzUHJldmlldyIsIl9pbml0aWFsTWF0Y2hlc01pZGRsZXdhcmVQcm9taXNlIiwicmVuZGVyQ3R4IiwiaW5pdGlhbCIsImJlZm9yZVJlbmRlciIsIl9fZXNNb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/index.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/next-dev.js":
/*!***************************************************!*\
  !*** ./node_modules/next/dist/client/next-dev.js ***!
  \***************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("// TODO: Remove use of `any` type.\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _ = __webpack_require__(/*! ./ */ \"./node_modules/next/dist/client/index.js\");\nconst _ondemandentriesclient = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./dev/on-demand-entries-client */ \"./node_modules/next/dist/client/dev/on-demand-entries-client.js\"));\nconst _webpackhotmiddlewareclient = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./dev/webpack-hot-middleware-client */ \"./node_modules/next/dist/client/dev/webpack-hot-middleware-client.js\"));\nconst _devbuildwatcher = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./dev/dev-build-watcher */ \"./node_modules/next/dist/client/dev/dev-build-watcher.js\"));\nconst _fouc = __webpack_require__(/*! ./dev/fouc */ \"./node_modules/next/dist/client/dev/fouc.js\");\nconst _websocket = __webpack_require__(/*! ./dev/error-overlay/websocket */ \"./node_modules/next/dist/client/dev/error-overlay/websocket.js\");\nconst _querystring = __webpack_require__(/*! ../shared/lib/router/utils/querystring */ \"./node_modules/next/dist/shared/lib/router/utils/querystring.js\");\nif (!window._nextSetupHydrationWarning) {\n    const origConsoleError = window.console.error;\n    window.console.error = function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        const isHydrateError = args.some((arg)=>typeof arg === \"string\" && arg.match(/(hydration|content does not match|did not match)/i));\n        if (isHydrateError) {\n            args = [\n                ...args,\n                \"\\n\\nSee more info here: https://nextjs.org/docs/messages/react-hydration-error\"\n            ];\n        }\n        origConsoleError.apply(window.console, args);\n    };\n    window._nextSetupHydrationWarning = true;\n}\nwindow.next = {\n    version: _.version,\n    // router is initialized later so it has to be live-binded\n    get router () {\n        return _.router;\n    },\n    emitter: _.emitter\n};\nconst webpackHMR = (0, _webpackhotmiddlewareclient.default)();\n(0, _.initialize)({\n    webpackHMR\n}).then((param)=>{\n    let { assetPrefix } = param;\n    (0, _websocket.connectHMR)({\n        assetPrefix,\n        path: \"/_next/webpack-hmr\"\n    });\n    return (0, _.hydrate)({\n        beforeRender: _fouc.displayContent\n    }).then(()=>{\n        (0, _ondemandentriesclient.default)();\n        let buildIndicatorHandler = ()=>{};\n        function devPagesHmrListener(event) {\n            let payload;\n            try {\n                payload = JSON.parse(event.data);\n            } catch (e) {}\n            if (payload.event === \"server-error\" && payload.errorJSON) {\n                const { stack, message } = JSON.parse(payload.errorJSON);\n                const error = new Error(message);\n                error.stack = stack;\n                throw error;\n            } else if (payload.action === \"reloadPage\") {\n                window.location.reload();\n            } else if (payload.action === \"devPagesManifestUpdate\") {\n                fetch(\"\" + assetPrefix + \"/_next/static/development/_devPagesManifest.json\").then((res)=>res.json()).then((manifest)=>{\n                    window.__DEV_PAGES_MANIFEST = manifest;\n                }).catch((err)=>{\n                    console.log(\"Failed to fetch devPagesManifest\", err);\n                });\n            } else if (payload.event === \"middlewareChanges\") {\n                return window.location.reload();\n            } else if (payload.event === \"serverOnlyChanges\") {\n                const { pages } = payload;\n                // Make sure to reload when the dev-overlay is showing for an\n                // API route\n                if (pages.includes(_.router.query.__NEXT_PAGE)) {\n                    return window.location.reload();\n                }\n                if (!_.router.clc && pages.includes(_.router.pathname)) {\n                    console.log(\"Refreshing page data due to server-side change\");\n                    buildIndicatorHandler(\"building\");\n                    const clearIndicator = ()=>buildIndicatorHandler(\"built\");\n                    _.router.replace(_.router.pathname + \"?\" + String((0, _querystring.assign)((0, _querystring.urlQueryToSearchParams)(_.router.query), new URLSearchParams(location.search))), _.router.asPath, {\n                        scroll: false\n                    }).catch(()=>{\n                        // trigger hard reload when failing to refresh data\n                        // to show error overlay properly\n                        location.reload();\n                    }).finally(clearIndicator);\n                }\n            }\n        }\n        (0, _websocket.addMessageListener)(devPagesHmrListener);\n        if (true) {\n            (0, _devbuildwatcher.default)((handler)=>{\n                buildIndicatorHandler = handler;\n            }, \"bottom-right\");\n        }\n    });\n}).catch((err)=>{\n    console.error(\"Error was not caught\", err);\n});\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=next-dev.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9uZXh0LWRldi5qcyIsIm1hcHBpbmdzIjoiQUFBQSxrQ0FBa0M7QUFDckI7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsMkJBQTJCQyxtQkFBT0EsQ0FBQyw0R0FBeUM7QUFDbEYsTUFBTUMsSUFBSUQsbUJBQU9BLENBQUMsb0RBQUk7QUFDdEIsTUFBTUUseUJBQXlCLFdBQVcsR0FBR0gseUJBQXlCRSxDQUFDLENBQUNELG1CQUFPQSxDQUFDLHVHQUFnQztBQUNoSCxNQUFNRyw4QkFBOEIsV0FBVyxHQUFHSix5QkFBeUJFLENBQUMsQ0FBQ0QsbUJBQU9BLENBQUMsaUhBQXFDO0FBQzFILE1BQU1JLG1CQUFtQixXQUFXLEdBQUdMLHlCQUF5QkUsQ0FBQyxDQUFDRCxtQkFBT0EsQ0FBQyx5RkFBeUI7QUFDbkcsTUFBTUssUUFBUUwsbUJBQU9BLENBQUMsK0RBQVk7QUFDbEMsTUFBTU0sYUFBYU4sbUJBQU9BLENBQUMscUdBQStCO0FBQzFELE1BQU1PLGVBQWVQLG1CQUFPQSxDQUFDLCtHQUF3QztBQUNyRSxJQUFJLENBQUNRLE9BQU9DLDBCQUEwQixFQUFFO0lBQ3BDLE1BQU1DLG1CQUFtQkYsT0FBT0csT0FBTyxDQUFDQyxLQUFLO0lBQzdDSixPQUFPRyxPQUFPLENBQUNDLEtBQUssR0FBRztRQUNuQixJQUFJLElBQUlDLE9BQU9DLFVBQVVDLE1BQU0sRUFBRUMsT0FBTyxJQUFJQyxNQUFNSixPQUFPSyxPQUFPLEdBQUdBLE9BQU9MLE1BQU1LLE9BQU87WUFDbkZGLElBQUksQ0FBQ0UsS0FBSyxHQUFHSixTQUFTLENBQUNJLEtBQUs7UUFDaEM7UUFDQSxNQUFNQyxpQkFBaUJILEtBQUtJLElBQUksQ0FBQyxDQUFDQyxNQUFNLE9BQU9BLFFBQVEsWUFBWUEsSUFBSUMsS0FBSyxDQUFDO1FBQzdFLElBQUlILGdCQUFnQjtZQUNoQkgsT0FBTzttQkFDQUE7Z0JBQ0g7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SUFBSVMsZ0JBQWdCckIsU0FBU3NCLE1BQU0sS0FBS3pFLEVBQUV5QixNQUFNLENBQUNpRCxNQUFNLEVBQUU7d0JBQzFMQyxRQUFRO29CQUNaLEdBQUdqQixLQUFLLENBQUM7d0JBQ0wsbURBQW1EO3dCQUNuRCxpQ0FBaUM7d0JBQ2pDUCxTQUFTQyxNQUFNO29CQUNuQixHQUFHd0IsT0FBTyxDQUFDVDtnQkFDZjtZQUNKO1FBQ0o7UUFDQyxJQUFHOUQsV0FBV3dFLGtCQUFrQixFQUFFdEM7UUFDbkMsSUFBSXVDLElBQWtDLEVBQUU7WUFDbkMsSUFBRzNFLGlCQUFpQnlCLE9BQU8sRUFBRSxDQUFDcUQ7Z0JBQzNCM0Msd0JBQXdCMkM7WUFDNUIsR0FBR0gsY0FBMkM7UUFDbEQ7SUFDSjtBQUNKLEdBQUdwQixLQUFLLENBQUMsQ0FBQ0M7SUFDTmpELFFBQVFDLEtBQUssQ0FBQyx3QkFBd0JnRDtBQUMxQztBQUVBLElBQUksQ0FBQyxPQUFPL0QsUUFBUWdDLE9BQU8sS0FBSyxjQUFlLE9BQU9oQyxRQUFRZ0MsT0FBTyxLQUFLLFlBQVloQyxRQUFRZ0MsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPaEMsUUFBUWdDLE9BQU8sQ0FBQ3VELFVBQVUsS0FBSyxhQUFhO0lBQ3JLekYsT0FBT0MsY0FBYyxDQUFDQyxRQUFRZ0MsT0FBTyxFQUFFLGNBQWM7UUFBRS9CLE9BQU87SUFBSztJQUNuRUgsT0FBTzRFLE1BQU0sQ0FBQzFFLFFBQVFnQyxPQUFPLEVBQUVoQztJQUMvQndGLE9BQU94RixPQUFPLEdBQUdBLFFBQVFnQyxPQUFPO0FBQ2xDLEVBRUEsb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L25leHQtZGV2LmpzPzM1MTUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVE9ETzogUmVtb3ZlIHVzZSBvZiBgYW55YCB0eXBlLlxuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5jb25zdCBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL18vX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0XCIpO1xuY29uc3QgXyA9IHJlcXVpcmUoXCIuL1wiKTtcbmNvbnN0IF9vbmRlbWFuZGVudHJpZXNjbGllbnQgPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5fKHJlcXVpcmUoXCIuL2Rldi9vbi1kZW1hbmQtZW50cmllcy1jbGllbnRcIikpO1xuY29uc3QgX3dlYnBhY2tob3RtaWRkbGV3YXJlY2xpZW50ID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuXyhyZXF1aXJlKFwiLi9kZXYvd2VicGFjay1ob3QtbWlkZGxld2FyZS1jbGllbnRcIikpO1xuY29uc3QgX2RldmJ1aWxkd2F0Y2hlciA9IC8qI19fUFVSRV9fKi8gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0Ll8ocmVxdWlyZShcIi4vZGV2L2Rldi1idWlsZC13YXRjaGVyXCIpKTtcbmNvbnN0IF9mb3VjID0gcmVxdWlyZShcIi4vZGV2L2ZvdWNcIik7XG5jb25zdCBfd2Vic29ja2V0ID0gcmVxdWlyZShcIi4vZGV2L2Vycm9yLW92ZXJsYXkvd2Vic29ja2V0XCIpO1xuY29uc3QgX3F1ZXJ5c3RyaW5nID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3F1ZXJ5c3RyaW5nXCIpO1xuaWYgKCF3aW5kb3cuX25leHRTZXR1cEh5ZHJhdGlvbldhcm5pbmcpIHtcbiAgICBjb25zdCBvcmlnQ29uc29sZUVycm9yID0gd2luZG93LmNvbnNvbGUuZXJyb3I7XG4gICAgd2luZG93LmNvbnNvbGUuZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc0h5ZHJhdGVFcnJvciA9IGFyZ3Muc29tZSgoYXJnKT0+dHlwZW9mIGFyZyA9PT0gXCJzdHJpbmdcIiAmJiBhcmcubWF0Y2goLyhoeWRyYXRpb258Y29udGVudCBkb2VzIG5vdCBtYXRjaHxkaWQgbm90IG1hdGNoKS9pKSk7XG4gICAgICAgIGlmIChpc0h5ZHJhdGVFcnJvcikge1xuICAgICAgICAgICAgYXJncyA9IFtcbiAgICAgICAgICAgICAgICAuLi5hcmdzLFxuICAgICAgICAgICAgICAgIFwiXFxuXFxuU2VlIG1vcmUgaW5mbyBoZXJlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9yZWFjdC1oeWRyYXRpb24tZXJyb3JcIlxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICBvcmlnQ29uc29sZUVycm9yLmFwcGx5KHdpbmRvdy5jb25zb2xlLCBhcmdzKTtcbiAgICB9O1xuICAgIHdpbmRvdy5fbmV4dFNldHVwSHlkcmF0aW9uV2FybmluZyA9IHRydWU7XG59XG53aW5kb3cubmV4dCA9IHtcbiAgICB2ZXJzaW9uOiBfLnZlcnNpb24sXG4gICAgLy8gcm91dGVyIGlzIGluaXRpYWxpemVkIGxhdGVyIHNvIGl0IGhhcyB0byBiZSBsaXZlLWJpbmRlZFxuICAgIGdldCByb3V0ZXIgKCkge1xuICAgICAgICByZXR1cm4gXy5yb3V0ZXI7XG4gICAgfSxcbiAgICBlbWl0dGVyOiBfLmVtaXR0ZXJcbn07XG5jb25zdCB3ZWJwYWNrSE1SID0gKDAsIF93ZWJwYWNraG90bWlkZGxld2FyZWNsaWVudC5kZWZhdWx0KSgpO1xuKDAsIF8uaW5pdGlhbGl6ZSkoe1xuICAgIHdlYnBhY2tITVJcbn0pLnRoZW4oKHBhcmFtKT0+e1xuICAgIGxldCB7IGFzc2V0UHJlZml4ICB9ID0gcGFyYW07XG4gICAgKDAsIF93ZWJzb2NrZXQuY29ubmVjdEhNUikoe1xuICAgICAgICBhc3NldFByZWZpeCxcbiAgICAgICAgcGF0aDogXCIvX25leHQvd2VicGFjay1obXJcIlxuICAgIH0pO1xuICAgIHJldHVybiAoMCwgXy5oeWRyYXRlKSh7XG4gICAgICAgIGJlZm9yZVJlbmRlcjogX2ZvdWMuZGlzcGxheUNvbnRlbnRcbiAgICB9KS50aGVuKCgpPT57XG4gICAgICAgICgwLCBfb25kZW1hbmRlbnRyaWVzY2xpZW50LmRlZmF1bHQpKCk7XG4gICAgICAgIGxldCBidWlsZEluZGljYXRvckhhbmRsZXIgPSAoKT0+e307XG4gICAgICAgIGZ1bmN0aW9uIGRldlBhZ2VzSG1yTGlzdGVuZXIoZXZlbnQpIHtcbiAgICAgICAgICAgIGxldCBwYXlsb2FkO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkID0gSlNPTi5wYXJzZShldmVudC5kYXRhKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgICAgICBpZiAocGF5bG9hZC5ldmVudCA9PT0gXCJzZXJ2ZXItZXJyb3JcIiAmJiBwYXlsb2FkLmVycm9ySlNPTikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgc3RhY2sgLCBtZXNzYWdlICB9ID0gSlNPTi5wYXJzZShwYXlsb2FkLmVycm9ySlNPTik7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgZXJyb3Iuc3RhY2sgPSBzdGFjaztcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGF5bG9hZC5hY3Rpb24gPT09IFwicmVsb2FkUGFnZVwiKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXlsb2FkLmFjdGlvbiA9PT0gXCJkZXZQYWdlc01hbmlmZXN0VXBkYXRlXCIpIHtcbiAgICAgICAgICAgICAgICBmZXRjaChcIlwiICsgYXNzZXRQcmVmaXggKyBcIi9fbmV4dC9zdGF0aWMvZGV2ZWxvcG1lbnQvX2RldlBhZ2VzTWFuaWZlc3QuanNvblwiKS50aGVuKChyZXMpPT5yZXMuanNvbigpKS50aGVuKChtYW5pZmVzdCk9PntcbiAgICAgICAgICAgICAgICAgICAgd2luZG93Ll9fREVWX1BBR0VTX01BTklGRVNUID0gbWFuaWZlc3Q7XG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goKGVycik9PntcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJGYWlsZWQgdG8gZmV0Y2ggZGV2UGFnZXNNYW5pZmVzdFwiLCBlcnIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXlsb2FkLmV2ZW50ID09PSBcIm1pZGRsZXdhcmVDaGFuZ2VzXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXlsb2FkLmV2ZW50ID09PSBcInNlcnZlck9ubHlDaGFuZ2VzXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHBhZ2VzICB9ID0gcGF5bG9hZDtcbiAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdG8gcmVsb2FkIHdoZW4gdGhlIGRldi1vdmVybGF5IGlzIHNob3dpbmcgZm9yIGFuXG4gICAgICAgICAgICAgICAgLy8gQVBJIHJvdXRlXG4gICAgICAgICAgICAgICAgaWYgKHBhZ2VzLmluY2x1ZGVzKF8ucm91dGVyLnF1ZXJ5Ll9fTkVYVF9QQUdFKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIV8ucm91dGVyLmNsYyAmJiBwYWdlcy5pbmNsdWRlcyhfLnJvdXRlci5wYXRobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJSZWZyZXNoaW5nIHBhZ2UgZGF0YSBkdWUgdG8gc2VydmVyLXNpZGUgY2hhbmdlXCIpO1xuICAgICAgICAgICAgICAgICAgICBidWlsZEluZGljYXRvckhhbmRsZXIoXCJidWlsZGluZ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2xlYXJJbmRpY2F0b3IgPSAoKT0+YnVpbGRJbmRpY2F0b3JIYW5kbGVyKFwiYnVpbHRcIik7XG4gICAgICAgICAgICAgICAgICAgIF8ucm91dGVyLnJlcGxhY2UoXy5yb3V0ZXIucGF0aG5hbWUgKyBcIj9cIiArIFN0cmluZygoMCwgX3F1ZXJ5c3RyaW5nLmFzc2lnbikoKDAsIF9xdWVyeXN0cmluZy51cmxRdWVyeVRvU2VhcmNoUGFyYW1zKShfLnJvdXRlci5xdWVyeSksIG5ldyBVUkxTZWFyY2hQYXJhbXMobG9jYXRpb24uc2VhcmNoKSkpLCBfLnJvdXRlci5hc1BhdGgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbDogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goKCk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRyaWdnZXIgaGFyZCByZWxvYWQgd2hlbiBmYWlsaW5nIHRvIHJlZnJlc2ggZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG8gc2hvdyBlcnJvciBvdmVybGF5IHByb3Blcmx5XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbi5yZWxvYWQoKTtcbiAgICAgICAgICAgICAgICAgICAgfSkuZmluYWxseShjbGVhckluZGljYXRvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgICgwLCBfd2Vic29ja2V0LmFkZE1lc3NhZ2VMaXN0ZW5lcikoZGV2UGFnZXNIbXJMaXN0ZW5lcik7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfQlVJTERfSU5ESUNBVE9SKSB7XG4gICAgICAgICAgICAoMCwgX2RldmJ1aWxkd2F0Y2hlci5kZWZhdWx0KSgoaGFuZGxlcik9PntcbiAgICAgICAgICAgICAgICBidWlsZEluZGljYXRvckhhbmRsZXIgPSBoYW5kbGVyO1xuICAgICAgICAgICAgfSwgcHJvY2Vzcy5lbnYuX19ORVhUX0JVSUxEX0lORElDQVRPUl9QT1NJVElPTik7XG4gICAgICAgIH1cbiAgICB9KTtcbn0pLmNhdGNoKChlcnIpPT57XG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIHdhcyBub3QgY2F1Z2h0XCIsIGVycik7XG59KTtcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmV4dC1kZXYuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0IiwicmVxdWlyZSIsIl8iLCJfb25kZW1hbmRlbnRyaWVzY2xpZW50IiwiX3dlYnBhY2tob3RtaWRkbGV3YXJlY2xpZW50IiwiX2RldmJ1aWxkd2F0Y2hlciIsIl9mb3VjIiwiX3dlYnNvY2tldCIsIl9xdWVyeXN0cmluZyIsIndpbmRvdyIsIl9uZXh0U2V0dXBIeWRyYXRpb25XYXJuaW5nIiwib3JpZ0NvbnNvbGVFcnJvciIsImNvbnNvbGUiLCJlcnJvciIsIl9sZW4iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJhcmdzIiwiQXJyYXkiLCJfa2V5IiwiaXNIeWRyYXRlRXJyb3IiLCJzb21lIiwiYXJnIiwibWF0Y2giLCJhcHBseSIsIm5leHQiLCJ2ZXJzaW9uIiwicm91dGVyIiwiZW1pdHRlciIsIndlYnBhY2tITVIiLCJkZWZhdWx0IiwiaW5pdGlhbGl6ZSIsInRoZW4iLCJwYXJhbSIsImFzc2V0UHJlZml4IiwiY29ubmVjdEhNUiIsInBhdGgiLCJoeWRyYXRlIiwiYmVmb3JlUmVuZGVyIiwiZGlzcGxheUNvbnRlbnQiLCJidWlsZEluZGljYXRvckhhbmRsZXIiLCJkZXZQYWdlc0htckxpc3RlbmVyIiwiZXZlbnQiLCJwYXlsb2FkIiwiSlNPTiIsInBhcnNlIiwiZGF0YSIsImUiLCJlcnJvckpTT04iLCJzdGFjayIsIm1lc3NhZ2UiLCJFcnJvciIsImFjdGlvbiIsImxvY2F0aW9uIiwicmVsb2FkIiwiZmV0Y2giLCJyZXMiLCJqc29uIiwibWFuaWZlc3QiLCJfX0RFVl9QQUdFU19NQU5JRkVTVCIsImNhdGNoIiwiZXJyIiwibG9nIiwicGFnZXMiLCJpbmNsdWRlcyIsInF1ZXJ5IiwiX19ORVhUX1BBR0UiLCJjbGMiLCJwYXRobmFtZSIsImNsZWFySW5kaWNhdG9yIiwicmVwbGFjZSIsIlN0cmluZyIsImFzc2lnbiIsInVybFF1ZXJ5VG9TZWFyY2hQYXJhbXMiLCJVUkxTZWFyY2hQYXJhbXMiLCJzZWFyY2giLCJhc1BhdGgiLCJzY3JvbGwiLCJmaW5hbGx5IiwiYWRkTWVzc2FnZUxpc3RlbmVyIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9CVUlMRF9JTkRJQ0FUT1IiLCJoYW5kbGVyIiwiX19ORVhUX0JVSUxEX0lORElDQVRPUl9QT1NJVElPTiIsIl9fZXNNb2R1bGUiLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/next-dev.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/remove-base-path.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/client/remove-base-path.js ***!
  \***********************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"removeBasePath\", ({\n    enumerable: true,\n    get: function() {\n        return removeBasePath;\n    }\n}));\nconst _hasbasepath = __webpack_require__(/*! ./has-base-path */ \"./node_modules/next/dist/client/has-base-path.js\");\nconst basePath =  false || \"\";\nfunction removeBasePath(path) {\n    if (false) {}\n    path = path.slice(basePath.length);\n    if (!path.startsWith(\"/\")) path = \"/\" + path;\n    return path;\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=remove-base-path.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9yZW1vdmUtYmFzZS1wYXRoLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGSCxrREFBaUQ7SUFDN0NJLFlBQVk7SUFDWkMsS0FBSztRQUNELE9BQU9DO0lBQ1g7QUFDSixDQUFDLEVBQUM7QUFDRixNQUFNQyxlQUFlQyxtQkFBT0EsQ0FBQyx5RUFBaUI7QUFDOUMsTUFBTUMsV0FBV0MsTUFBa0MsSUFBSTtBQUN2RCxTQUFTSixlQUFlTyxJQUFJO0lBQ3hCLElBQUlILEtBQTBDLEVBQUUsRUFJL0M7SUFDREcsT0FBT0EsS0FBS0csS0FBSyxDQUFDUCxTQUFTUSxNQUFNO0lBQ2pDLElBQUksQ0FBQ0osS0FBS0ssVUFBVSxDQUFDLE1BQU1MLE9BQU8sTUFBTUE7SUFDeEMsT0FBT0E7QUFDWDtBQUVBLElBQUksQ0FBQyxPQUFPWCxRQUFRaUIsT0FBTyxLQUFLLGNBQWUsT0FBT2pCLFFBQVFpQixPQUFPLEtBQUssWUFBWWpCLFFBQVFpQixPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9qQixRQUFRaUIsT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNyS3BCLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUWlCLE9BQU8sRUFBRSxjQUFjO1FBQUVoQixPQUFPO0lBQUs7SUFDbkVILE9BQU9xQixNQUFNLENBQUNuQixRQUFRaUIsT0FBTyxFQUFFakI7SUFDL0JvQixPQUFPcEIsT0FBTyxHQUFHQSxRQUFRaUIsT0FBTztBQUNsQyxFQUVBLDRDQUE0QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9yZW1vdmUtYmFzZS1wYXRoLmpzP2I0ZjEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyZW1vdmVCYXNlUGF0aFwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcmVtb3ZlQmFzZVBhdGg7XG4gICAgfVxufSk7XG5jb25zdCBfaGFzYmFzZXBhdGggPSByZXF1aXJlKFwiLi9oYXMtYmFzZS1wYXRoXCIpO1xuY29uc3QgYmFzZVBhdGggPSBwcm9jZXNzLmVudi5fX05FWFRfUk9VVEVSX0JBU0VQQVRIIHx8IFwiXCI7XG5mdW5jdGlvbiByZW1vdmVCYXNlUGF0aChwYXRoKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9NQU5VQUxfQ0xJRU5UX0JBU0VfUEFUSCkge1xuICAgICAgICBpZiAoISgwLCBfaGFzYmFzZXBhdGguaGFzQmFzZVBhdGgpKHBhdGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwYXRoID0gcGF0aC5zbGljZShiYXNlUGF0aC5sZW5ndGgpO1xuICAgIGlmICghcGF0aC5zdGFydHNXaXRoKFwiL1wiKSkgcGF0aCA9IFwiL1wiICsgcGF0aDtcbiAgICByZXR1cm4gcGF0aDtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVtb3ZlLWJhc2UtcGF0aC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwicmVtb3ZlQmFzZVBhdGgiLCJfaGFzYmFzZXBhdGgiLCJyZXF1aXJlIiwiYmFzZVBhdGgiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX1JPVVRFUl9CQVNFUEFUSCIsInBhdGgiLCJfX05FWFRfTUFOVUFMX0NMSUVOVF9CQVNFX1BBVEgiLCJoYXNCYXNlUGF0aCIsInNsaWNlIiwibGVuZ3RoIiwic3RhcnRzV2l0aCIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/remove-base-path.js\n"));

/***/ })

});